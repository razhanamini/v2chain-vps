"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterService = void 0;
const nice_grpc_1 = require("nice-grpc");
const ipaddr_js_1 = __importDefault(require("ipaddr.js"));
const command_1 = require("../xray-protos/app/router/command/command");
const create_typed_message_1 = __importDefault(require("../common/utils/create-typed-message/create-typed-message"));
const models_1 = require("./models");
const config_1 = require("../xray-protos/app/router/config");
const router_errors_1 = require("../common/errors/router/router.errors");
/**
 * Service for managing routing rules in XRAY/XTLS
 * RoutingService is required (enable on XRay Config) to add/remove routing rules.
 */
class RouterService {
    /**
     * Creates an instance of RouterService
     * @param channel - The gRPC channel to use for communication
     */
    constructor(channel) {
        this.channel = channel;
        this.client = (0, nice_grpc_1.createClient)(command_1.RoutingServiceDefinition, channel);
    }
    /**
     * Adds a new routing rule based on source IP address
     * @param dto - Data transfer object containing rule configuration
     * @param dto.ruleTag - Unique identifier for the rule
     * @param dto.outbound - Outbound tag to route matched traffic
     * @param dto.ip - Source IP address to match
     * @param dto.append - Whether to append the rule or replace existing rules
     * @returns Promise resolving to response indicating success or failure
     */
    async addSrcIpRule(dto) {
        try {
            const ip = ipaddr_js_1.default.parse(dto.ip);
            const prefix = ip.kind() === 'ipv6' ? 128 : 32;
            await this.client.addRule({
                config: (0, create_typed_message_1.default)(config_1.Config, {
                    rule: [
                        {
                            ruleTag: dto.ruleTag,
                            tag: dto.outbound,
                            sourceGeoip: [
                                config_1.GeoIP.fromPartial({
                                    cidr: [
                                        config_1.CIDR.fromPartial({
                                            ip: new Uint8Array(ip.toByteArray()),
                                            prefix,
                                        }),
                                    ],
                                }),
                            ],
                        },
                    ],
                }),
                shouldAppend: dto.append,
            });
            return {
                isOk: true,
                data: new models_1.AddSourceIpRuleResponseModel(true),
            };
        }
        catch (error) {
            let message = '';
            if (error instanceof Error) {
                message = error.message;
            }
            return {
                isOk: false,
                ...router_errors_1.ROUTER_ERRORS.ADD_SOURCE_IP_RULE_ERROR(message),
            };
        }
    }
    /**
     * Removes a routing rule by its tag
     * @param dto - Data transfer object containing rule tag
     * @param dto.ruleTag - Tag of the rule to remove
     * @returns Promise resolving to response indicating success or failure
     */
    async removeRuleByRuleTag(dto) {
        try {
            await this.client.removeRule({
                ruleTag: dto.ruleTag,
            });
            return {
                isOk: true,
                data: new models_1.RemoveRuleByRuleTagResponseModel(true),
            };
        }
        catch (error) {
            let message = '';
            if (error instanceof Error) {
                message = error.message;
            }
            return {
                isOk: false,
                ...router_errors_1.ROUTER_ERRORS.REMOVE_RULE_BY_RULE_TAG_ERROR(message),
            };
        }
    }
    /**
     * Gets the raw gRPC client for direct access to all routing service methods
     * @returns The underlying RoutingServiceClient instance
     */
    get rawClient() {
        return this.client;
    }
}
exports.RouterService = RouterService;
