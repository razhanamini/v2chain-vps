"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v5.29.3
// source: proxy/wireguard/config.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceConfig = exports.PeerConfig = exports.DeviceConfig_DomainStrategy = exports.protobufPackage = void 0;
exports.deviceConfig_DomainStrategyFromJSON = deviceConfig_DomainStrategyFromJSON;
exports.deviceConfig_DomainStrategyToJSON = deviceConfig_DomainStrategyToJSON;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const typeRegistry_1 = require("../../typeRegistry");
exports.protobufPackage = "xray.proxy.wireguard";
var DeviceConfig_DomainStrategy;
(function (DeviceConfig_DomainStrategy) {
    DeviceConfig_DomainStrategy[DeviceConfig_DomainStrategy["FORCE_IP"] = 0] = "FORCE_IP";
    DeviceConfig_DomainStrategy[DeviceConfig_DomainStrategy["FORCE_IP4"] = 1] = "FORCE_IP4";
    DeviceConfig_DomainStrategy[DeviceConfig_DomainStrategy["FORCE_IP6"] = 2] = "FORCE_IP6";
    DeviceConfig_DomainStrategy[DeviceConfig_DomainStrategy["FORCE_IP46"] = 3] = "FORCE_IP46";
    DeviceConfig_DomainStrategy[DeviceConfig_DomainStrategy["FORCE_IP64"] = 4] = "FORCE_IP64";
    DeviceConfig_DomainStrategy[DeviceConfig_DomainStrategy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DeviceConfig_DomainStrategy || (exports.DeviceConfig_DomainStrategy = DeviceConfig_DomainStrategy = {}));
function deviceConfig_DomainStrategyFromJSON(object) {
    switch (object) {
        case 0:
        case "FORCE_IP":
            return DeviceConfig_DomainStrategy.FORCE_IP;
        case 1:
        case "FORCE_IP4":
            return DeviceConfig_DomainStrategy.FORCE_IP4;
        case 2:
        case "FORCE_IP6":
            return DeviceConfig_DomainStrategy.FORCE_IP6;
        case 3:
        case "FORCE_IP46":
            return DeviceConfig_DomainStrategy.FORCE_IP46;
        case 4:
        case "FORCE_IP64":
            return DeviceConfig_DomainStrategy.FORCE_IP64;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DeviceConfig_DomainStrategy.UNRECOGNIZED;
    }
}
function deviceConfig_DomainStrategyToJSON(object) {
    switch (object) {
        case DeviceConfig_DomainStrategy.FORCE_IP:
            return "FORCE_IP";
        case DeviceConfig_DomainStrategy.FORCE_IP4:
            return "FORCE_IP4";
        case DeviceConfig_DomainStrategy.FORCE_IP6:
            return "FORCE_IP6";
        case DeviceConfig_DomainStrategy.FORCE_IP46:
            return "FORCE_IP46";
        case DeviceConfig_DomainStrategy.FORCE_IP64:
            return "FORCE_IP64";
        case DeviceConfig_DomainStrategy.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBasePeerConfig() {
    return {
        $type: "xray.proxy.wireguard.PeerConfig",
        publicKey: "",
        preSharedKey: "",
        endpoint: "",
        keepAlive: 0,
        allowedIps: [],
    };
}
exports.PeerConfig = {
    $type: "xray.proxy.wireguard.PeerConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.publicKey !== "") {
            writer.uint32(10).string(message.publicKey);
        }
        if (message.preSharedKey !== "") {
            writer.uint32(18).string(message.preSharedKey);
        }
        if (message.endpoint !== "") {
            writer.uint32(26).string(message.endpoint);
        }
        if (message.keepAlive !== 0) {
            writer.uint32(32).uint32(message.keepAlive);
        }
        for (const v of message.allowedIps) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePeerConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.publicKey = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.preSharedKey = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.endpoint = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.keepAlive = reader.uint32();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.allowedIps.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.PeerConfig.$type,
            publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
            preSharedKey: isSet(object.preSharedKey) ? globalThis.String(object.preSharedKey) : "",
            endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
            keepAlive: isSet(object.keepAlive) ? globalThis.Number(object.keepAlive) : 0,
            allowedIps: globalThis.Array.isArray(object?.allowedIps)
                ? object.allowedIps.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.publicKey !== "") {
            obj.publicKey = message.publicKey;
        }
        if (message.preSharedKey !== "") {
            obj.preSharedKey = message.preSharedKey;
        }
        if (message.endpoint !== "") {
            obj.endpoint = message.endpoint;
        }
        if (message.keepAlive !== 0) {
            obj.keepAlive = Math.round(message.keepAlive);
        }
        if (message.allowedIps?.length) {
            obj.allowedIps = message.allowedIps;
        }
        return obj;
    },
    create(base) {
        return exports.PeerConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePeerConfig();
        message.publicKey = object.publicKey ?? "";
        message.preSharedKey = object.preSharedKey ?? "";
        message.endpoint = object.endpoint ?? "";
        message.keepAlive = object.keepAlive ?? 0;
        message.allowedIps = object.allowedIps?.map((e) => e) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.PeerConfig.$type, exports.PeerConfig);
function createBaseDeviceConfig() {
    return {
        $type: "xray.proxy.wireguard.DeviceConfig",
        secretKey: "",
        endpoint: [],
        peers: [],
        mtu: 0,
        numWorkers: 0,
        reserved: new Uint8Array(0),
        domainStrategy: 0,
        isClient: false,
        noKernelTun: false,
    };
}
exports.DeviceConfig = {
    $type: "xray.proxy.wireguard.DeviceConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.secretKey !== "") {
            writer.uint32(10).string(message.secretKey);
        }
        for (const v of message.endpoint) {
            writer.uint32(18).string(v);
        }
        for (const v of message.peers) {
            exports.PeerConfig.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.mtu !== 0) {
            writer.uint32(32).int32(message.mtu);
        }
        if (message.numWorkers !== 0) {
            writer.uint32(40).int32(message.numWorkers);
        }
        if (message.reserved.length !== 0) {
            writer.uint32(50).bytes(message.reserved);
        }
        if (message.domainStrategy !== 0) {
            writer.uint32(56).int32(message.domainStrategy);
        }
        if (message.isClient !== false) {
            writer.uint32(64).bool(message.isClient);
        }
        if (message.noKernelTun !== false) {
            writer.uint32(72).bool(message.noKernelTun);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeviceConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.secretKey = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.endpoint.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.peers.push(exports.PeerConfig.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.mtu = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.numWorkers = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.reserved = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.domainStrategy = reader.int32();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.isClient = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.noKernelTun = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.DeviceConfig.$type,
            secretKey: isSet(object.secretKey) ? globalThis.String(object.secretKey) : "",
            endpoint: globalThis.Array.isArray(object?.endpoint) ? object.endpoint.map((e) => globalThis.String(e)) : [],
            peers: globalThis.Array.isArray(object?.peers) ? object.peers.map((e) => exports.PeerConfig.fromJSON(e)) : [],
            mtu: isSet(object.mtu) ? globalThis.Number(object.mtu) : 0,
            numWorkers: isSet(object.numWorkers) ? globalThis.Number(object.numWorkers) : 0,
            reserved: isSet(object.reserved) ? bytesFromBase64(object.reserved) : new Uint8Array(0),
            domainStrategy: isSet(object.domainStrategy) ? deviceConfig_DomainStrategyFromJSON(object.domainStrategy) : 0,
            isClient: isSet(object.isClient) ? globalThis.Boolean(object.isClient) : false,
            noKernelTun: isSet(object.noKernelTun) ? globalThis.Boolean(object.noKernelTun) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.secretKey !== "") {
            obj.secretKey = message.secretKey;
        }
        if (message.endpoint?.length) {
            obj.endpoint = message.endpoint;
        }
        if (message.peers?.length) {
            obj.peers = message.peers.map((e) => exports.PeerConfig.toJSON(e));
        }
        if (message.mtu !== 0) {
            obj.mtu = Math.round(message.mtu);
        }
        if (message.numWorkers !== 0) {
            obj.numWorkers = Math.round(message.numWorkers);
        }
        if (message.reserved.length !== 0) {
            obj.reserved = base64FromBytes(message.reserved);
        }
        if (message.domainStrategy !== 0) {
            obj.domainStrategy = deviceConfig_DomainStrategyToJSON(message.domainStrategy);
        }
        if (message.isClient !== false) {
            obj.isClient = message.isClient;
        }
        if (message.noKernelTun !== false) {
            obj.noKernelTun = message.noKernelTun;
        }
        return obj;
    },
    create(base) {
        return exports.DeviceConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeviceConfig();
        message.secretKey = object.secretKey ?? "";
        message.endpoint = object.endpoint?.map((e) => e) || [];
        message.peers = object.peers?.map((e) => exports.PeerConfig.fromPartial(e)) || [];
        message.mtu = object.mtu ?? 0;
        message.numWorkers = object.numWorkers ?? 0;
        message.reserved = object.reserved ?? new Uint8Array(0);
        message.domainStrategy = object.domainStrategy ?? 0;
        message.isClient = object.isClient ?? false;
        message.noKernelTun = object.noKernelTun ?? false;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.DeviceConfig.$type, exports.DeviceConfig);
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
