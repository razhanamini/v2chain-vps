"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v5.29.3
// source: transport/internet/config.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.HappyEyeballsConfig = exports.SocketConfig = exports.CustomSockopt = exports.ProxyConfig = exports.StreamConfig = exports.TransportConfig = exports.SocketConfig_TProxyMode = exports.AddressPortStrategy = exports.DomainStrategy = exports.protobufPackage = void 0;
exports.domainStrategyFromJSON = domainStrategyFromJSON;
exports.domainStrategyToJSON = domainStrategyToJSON;
exports.addressPortStrategyFromJSON = addressPortStrategyFromJSON;
exports.addressPortStrategyToJSON = addressPortStrategyToJSON;
exports.socketConfig_TProxyModeFromJSON = socketConfig_TProxyModeFromJSON;
exports.socketConfig_TProxyModeToJSON = socketConfig_TProxyModeToJSON;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const address_1 = require("../../common/net/address");
const typed_message_1 = require("../../common/serial/typed_message");
const typeRegistry_1 = require("../../typeRegistry");
exports.protobufPackage = "xray.transport.internet";
var DomainStrategy;
(function (DomainStrategy) {
    DomainStrategy[DomainStrategy["AS_IS"] = 0] = "AS_IS";
    DomainStrategy[DomainStrategy["USE_IP"] = 1] = "USE_IP";
    DomainStrategy[DomainStrategy["USE_IP4"] = 2] = "USE_IP4";
    DomainStrategy[DomainStrategy["USE_IP6"] = 3] = "USE_IP6";
    DomainStrategy[DomainStrategy["USE_IP46"] = 4] = "USE_IP46";
    DomainStrategy[DomainStrategy["USE_IP64"] = 5] = "USE_IP64";
    DomainStrategy[DomainStrategy["FORCE_IP"] = 6] = "FORCE_IP";
    DomainStrategy[DomainStrategy["FORCE_IP4"] = 7] = "FORCE_IP4";
    DomainStrategy[DomainStrategy["FORCE_IP6"] = 8] = "FORCE_IP6";
    DomainStrategy[DomainStrategy["FORCE_IP46"] = 9] = "FORCE_IP46";
    DomainStrategy[DomainStrategy["FORCE_IP64"] = 10] = "FORCE_IP64";
    DomainStrategy[DomainStrategy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DomainStrategy || (exports.DomainStrategy = DomainStrategy = {}));
function domainStrategyFromJSON(object) {
    switch (object) {
        case 0:
        case "AS_IS":
            return DomainStrategy.AS_IS;
        case 1:
        case "USE_IP":
            return DomainStrategy.USE_IP;
        case 2:
        case "USE_IP4":
            return DomainStrategy.USE_IP4;
        case 3:
        case "USE_IP6":
            return DomainStrategy.USE_IP6;
        case 4:
        case "USE_IP46":
            return DomainStrategy.USE_IP46;
        case 5:
        case "USE_IP64":
            return DomainStrategy.USE_IP64;
        case 6:
        case "FORCE_IP":
            return DomainStrategy.FORCE_IP;
        case 7:
        case "FORCE_IP4":
            return DomainStrategy.FORCE_IP4;
        case 8:
        case "FORCE_IP6":
            return DomainStrategy.FORCE_IP6;
        case 9:
        case "FORCE_IP46":
            return DomainStrategy.FORCE_IP46;
        case 10:
        case "FORCE_IP64":
            return DomainStrategy.FORCE_IP64;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DomainStrategy.UNRECOGNIZED;
    }
}
function domainStrategyToJSON(object) {
    switch (object) {
        case DomainStrategy.AS_IS:
            return "AS_IS";
        case DomainStrategy.USE_IP:
            return "USE_IP";
        case DomainStrategy.USE_IP4:
            return "USE_IP4";
        case DomainStrategy.USE_IP6:
            return "USE_IP6";
        case DomainStrategy.USE_IP46:
            return "USE_IP46";
        case DomainStrategy.USE_IP64:
            return "USE_IP64";
        case DomainStrategy.FORCE_IP:
            return "FORCE_IP";
        case DomainStrategy.FORCE_IP4:
            return "FORCE_IP4";
        case DomainStrategy.FORCE_IP6:
            return "FORCE_IP6";
        case DomainStrategy.FORCE_IP46:
            return "FORCE_IP46";
        case DomainStrategy.FORCE_IP64:
            return "FORCE_IP64";
        case DomainStrategy.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var AddressPortStrategy;
(function (AddressPortStrategy) {
    AddressPortStrategy[AddressPortStrategy["None"] = 0] = "None";
    AddressPortStrategy[AddressPortStrategy["SrvPortOnly"] = 1] = "SrvPortOnly";
    AddressPortStrategy[AddressPortStrategy["SrvAddressOnly"] = 2] = "SrvAddressOnly";
    AddressPortStrategy[AddressPortStrategy["SrvPortAndAddress"] = 3] = "SrvPortAndAddress";
    AddressPortStrategy[AddressPortStrategy["TxtPortOnly"] = 4] = "TxtPortOnly";
    AddressPortStrategy[AddressPortStrategy["TxtAddressOnly"] = 5] = "TxtAddressOnly";
    AddressPortStrategy[AddressPortStrategy["TxtPortAndAddress"] = 6] = "TxtPortAndAddress";
    AddressPortStrategy[AddressPortStrategy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AddressPortStrategy || (exports.AddressPortStrategy = AddressPortStrategy = {}));
function addressPortStrategyFromJSON(object) {
    switch (object) {
        case 0:
        case "None":
            return AddressPortStrategy.None;
        case 1:
        case "SrvPortOnly":
            return AddressPortStrategy.SrvPortOnly;
        case 2:
        case "SrvAddressOnly":
            return AddressPortStrategy.SrvAddressOnly;
        case 3:
        case "SrvPortAndAddress":
            return AddressPortStrategy.SrvPortAndAddress;
        case 4:
        case "TxtPortOnly":
            return AddressPortStrategy.TxtPortOnly;
        case 5:
        case "TxtAddressOnly":
            return AddressPortStrategy.TxtAddressOnly;
        case 6:
        case "TxtPortAndAddress":
            return AddressPortStrategy.TxtPortAndAddress;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AddressPortStrategy.UNRECOGNIZED;
    }
}
function addressPortStrategyToJSON(object) {
    switch (object) {
        case AddressPortStrategy.None:
            return "None";
        case AddressPortStrategy.SrvPortOnly:
            return "SrvPortOnly";
        case AddressPortStrategy.SrvAddressOnly:
            return "SrvAddressOnly";
        case AddressPortStrategy.SrvPortAndAddress:
            return "SrvPortAndAddress";
        case AddressPortStrategy.TxtPortOnly:
            return "TxtPortOnly";
        case AddressPortStrategy.TxtAddressOnly:
            return "TxtAddressOnly";
        case AddressPortStrategy.TxtPortAndAddress:
            return "TxtPortAndAddress";
        case AddressPortStrategy.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var SocketConfig_TProxyMode;
(function (SocketConfig_TProxyMode) {
    /** Off - TProxy is off. */
    SocketConfig_TProxyMode[SocketConfig_TProxyMode["Off"] = 0] = "Off";
    /** TProxy - TProxy mode. */
    SocketConfig_TProxyMode[SocketConfig_TProxyMode["TProxy"] = 1] = "TProxy";
    /** Redirect - Redirect mode. */
    SocketConfig_TProxyMode[SocketConfig_TProxyMode["Redirect"] = 2] = "Redirect";
    SocketConfig_TProxyMode[SocketConfig_TProxyMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SocketConfig_TProxyMode || (exports.SocketConfig_TProxyMode = SocketConfig_TProxyMode = {}));
function socketConfig_TProxyModeFromJSON(object) {
    switch (object) {
        case 0:
        case "Off":
            return SocketConfig_TProxyMode.Off;
        case 1:
        case "TProxy":
            return SocketConfig_TProxyMode.TProxy;
        case 2:
        case "Redirect":
            return SocketConfig_TProxyMode.Redirect;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SocketConfig_TProxyMode.UNRECOGNIZED;
    }
}
function socketConfig_TProxyModeToJSON(object) {
    switch (object) {
        case SocketConfig_TProxyMode.Off:
            return "Off";
        case SocketConfig_TProxyMode.TProxy:
            return "TProxy";
        case SocketConfig_TProxyMode.Redirect:
            return "Redirect";
        case SocketConfig_TProxyMode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseTransportConfig() {
    return { $type: "xray.transport.internet.TransportConfig", protocolName: "", settings: undefined };
}
exports.TransportConfig = {
    $type: "xray.transport.internet.TransportConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.protocolName !== "") {
            writer.uint32(26).string(message.protocolName);
        }
        if (message.settings !== undefined) {
            typed_message_1.TypedMessage.encode(message.settings, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransportConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.protocolName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.settings = typed_message_1.TypedMessage.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.TransportConfig.$type,
            protocolName: isSet(object.protocolName) ? globalThis.String(object.protocolName) : "",
            settings: isSet(object.settings) ? typed_message_1.TypedMessage.fromJSON(object.settings) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.protocolName !== "") {
            obj.protocolName = message.protocolName;
        }
        if (message.settings !== undefined) {
            obj.settings = typed_message_1.TypedMessage.toJSON(message.settings);
        }
        return obj;
    },
    create(base) {
        return exports.TransportConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransportConfig();
        message.protocolName = object.protocolName ?? "";
        message.settings = (object.settings !== undefined && object.settings !== null)
            ? typed_message_1.TypedMessage.fromPartial(object.settings)
            : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.TransportConfig.$type, exports.TransportConfig);
function createBaseStreamConfig() {
    return {
        $type: "xray.transport.internet.StreamConfig",
        address: undefined,
        port: 0,
        protocolName: "",
        transportSettings: [],
        securityType: "",
        securitySettings: [],
        socketSettings: undefined,
    };
}
exports.StreamConfig = {
    $type: "xray.transport.internet.StreamConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.address !== undefined) {
            address_1.IPOrDomain.encode(message.address, writer.uint32(66).fork()).join();
        }
        if (message.port !== 0) {
            writer.uint32(72).uint32(message.port);
        }
        if (message.protocolName !== "") {
            writer.uint32(42).string(message.protocolName);
        }
        for (const v of message.transportSettings) {
            exports.TransportConfig.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.securityType !== "") {
            writer.uint32(26).string(message.securityType);
        }
        for (const v of message.securitySettings) {
            typed_message_1.TypedMessage.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.socketSettings !== undefined) {
            exports.SocketConfig.encode(message.socketSettings, writer.uint32(50).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.address = address_1.IPOrDomain.decode(reader, reader.uint32());
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.port = reader.uint32();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.protocolName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transportSettings.push(exports.TransportConfig.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.securityType = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.securitySettings.push(typed_message_1.TypedMessage.decode(reader, reader.uint32()));
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.socketSettings = exports.SocketConfig.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.StreamConfig.$type,
            address: isSet(object.address) ? address_1.IPOrDomain.fromJSON(object.address) : undefined,
            port: isSet(object.port) ? globalThis.Number(object.port) : 0,
            protocolName: isSet(object.protocolName) ? globalThis.String(object.protocolName) : "",
            transportSettings: globalThis.Array.isArray(object?.transportSettings)
                ? object.transportSettings.map((e) => exports.TransportConfig.fromJSON(e))
                : [],
            securityType: isSet(object.securityType) ? globalThis.String(object.securityType) : "",
            securitySettings: globalThis.Array.isArray(object?.securitySettings)
                ? object.securitySettings.map((e) => typed_message_1.TypedMessage.fromJSON(e))
                : [],
            socketSettings: isSet(object.socketSettings) ? exports.SocketConfig.fromJSON(object.socketSettings) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== undefined) {
            obj.address = address_1.IPOrDomain.toJSON(message.address);
        }
        if (message.port !== 0) {
            obj.port = Math.round(message.port);
        }
        if (message.protocolName !== "") {
            obj.protocolName = message.protocolName;
        }
        if (message.transportSettings?.length) {
            obj.transportSettings = message.transportSettings.map((e) => exports.TransportConfig.toJSON(e));
        }
        if (message.securityType !== "") {
            obj.securityType = message.securityType;
        }
        if (message.securitySettings?.length) {
            obj.securitySettings = message.securitySettings.map((e) => typed_message_1.TypedMessage.toJSON(e));
        }
        if (message.socketSettings !== undefined) {
            obj.socketSettings = exports.SocketConfig.toJSON(message.socketSettings);
        }
        return obj;
    },
    create(base) {
        return exports.StreamConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStreamConfig();
        message.address = (object.address !== undefined && object.address !== null)
            ? address_1.IPOrDomain.fromPartial(object.address)
            : undefined;
        message.port = object.port ?? 0;
        message.protocolName = object.protocolName ?? "";
        message.transportSettings = object.transportSettings?.map((e) => exports.TransportConfig.fromPartial(e)) || [];
        message.securityType = object.securityType ?? "";
        message.securitySettings = object.securitySettings?.map((e) => typed_message_1.TypedMessage.fromPartial(e)) || [];
        message.socketSettings = (object.socketSettings !== undefined && object.socketSettings !== null)
            ? exports.SocketConfig.fromPartial(object.socketSettings)
            : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.StreamConfig.$type, exports.StreamConfig);
function createBaseProxyConfig() {
    return { $type: "xray.transport.internet.ProxyConfig", tag: "", transportLayerProxy: false };
}
exports.ProxyConfig = {
    $type: "xray.transport.internet.ProxyConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tag !== "") {
            writer.uint32(10).string(message.tag);
        }
        if (message.transportLayerProxy !== false) {
            writer.uint32(16).bool(message.transportLayerProxy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProxyConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tag = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.transportLayerProxy = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.ProxyConfig.$type,
            tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
            transportLayerProxy: isSet(object.transportLayerProxy) ? globalThis.Boolean(object.transportLayerProxy) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tag !== "") {
            obj.tag = message.tag;
        }
        if (message.transportLayerProxy !== false) {
            obj.transportLayerProxy = message.transportLayerProxy;
        }
        return obj;
    },
    create(base) {
        return exports.ProxyConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProxyConfig();
        message.tag = object.tag ?? "";
        message.transportLayerProxy = object.transportLayerProxy ?? false;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.ProxyConfig.$type, exports.ProxyConfig);
function createBaseCustomSockopt() {
    return {
        $type: "xray.transport.internet.CustomSockopt",
        system: "",
        network: "",
        level: "",
        opt: "",
        value: "",
        type: "",
    };
}
exports.CustomSockopt = {
    $type: "xray.transport.internet.CustomSockopt",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.system !== "") {
            writer.uint32(10).string(message.system);
        }
        if (message.network !== "") {
            writer.uint32(18).string(message.network);
        }
        if (message.level !== "") {
            writer.uint32(26).string(message.level);
        }
        if (message.opt !== "") {
            writer.uint32(34).string(message.opt);
        }
        if (message.value !== "") {
            writer.uint32(42).string(message.value);
        }
        if (message.type !== "") {
            writer.uint32(50).string(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomSockopt();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.system = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.network = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.level = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.opt = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.CustomSockopt.$type,
            system: isSet(object.system) ? globalThis.String(object.system) : "",
            network: isSet(object.network) ? globalThis.String(object.network) : "",
            level: isSet(object.level) ? globalThis.String(object.level) : "",
            opt: isSet(object.opt) ? globalThis.String(object.opt) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.system !== "") {
            obj.system = message.system;
        }
        if (message.network !== "") {
            obj.network = message.network;
        }
        if (message.level !== "") {
            obj.level = message.level;
        }
        if (message.opt !== "") {
            obj.opt = message.opt;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        return obj;
    },
    create(base) {
        return exports.CustomSockopt.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCustomSockopt();
        message.system = object.system ?? "";
        message.network = object.network ?? "";
        message.level = object.level ?? "";
        message.opt = object.opt ?? "";
        message.value = object.value ?? "";
        message.type = object.type ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.CustomSockopt.$type, exports.CustomSockopt);
function createBaseSocketConfig() {
    return {
        $type: "xray.transport.internet.SocketConfig",
        mark: 0,
        tfo: 0,
        tproxy: 0,
        receiveOriginalDestAddress: false,
        bindAddress: new Uint8Array(0),
        bindPort: 0,
        acceptProxyProtocol: false,
        domainStrategy: 0,
        dialerProxy: "",
        tcpKeepAliveInterval: 0,
        tcpKeepAliveIdle: 0,
        tcpCongestion: "",
        interface: "",
        v6only: false,
        tcpWindowClamp: 0,
        tcpUserTimeout: 0,
        tcpMaxSeg: 0,
        penetrate: false,
        tcpMptcp: false,
        customSockopt: [],
        addressPortStrategy: 0,
        happyEyeballs: undefined,
        trustedXForwardedFor: [],
    };
}
exports.SocketConfig = {
    $type: "xray.transport.internet.SocketConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.mark !== 0) {
            writer.uint32(8).int32(message.mark);
        }
        if (message.tfo !== 0) {
            writer.uint32(16).int32(message.tfo);
        }
        if (message.tproxy !== 0) {
            writer.uint32(24).int32(message.tproxy);
        }
        if (message.receiveOriginalDestAddress !== false) {
            writer.uint32(32).bool(message.receiveOriginalDestAddress);
        }
        if (message.bindAddress.length !== 0) {
            writer.uint32(42).bytes(message.bindAddress);
        }
        if (message.bindPort !== 0) {
            writer.uint32(48).uint32(message.bindPort);
        }
        if (message.acceptProxyProtocol !== false) {
            writer.uint32(56).bool(message.acceptProxyProtocol);
        }
        if (message.domainStrategy !== 0) {
            writer.uint32(64).int32(message.domainStrategy);
        }
        if (message.dialerProxy !== "") {
            writer.uint32(74).string(message.dialerProxy);
        }
        if (message.tcpKeepAliveInterval !== 0) {
            writer.uint32(80).int32(message.tcpKeepAliveInterval);
        }
        if (message.tcpKeepAliveIdle !== 0) {
            writer.uint32(88).int32(message.tcpKeepAliveIdle);
        }
        if (message.tcpCongestion !== "") {
            writer.uint32(98).string(message.tcpCongestion);
        }
        if (message.interface !== "") {
            writer.uint32(106).string(message.interface);
        }
        if (message.v6only !== false) {
            writer.uint32(112).bool(message.v6only);
        }
        if (message.tcpWindowClamp !== 0) {
            writer.uint32(120).int32(message.tcpWindowClamp);
        }
        if (message.tcpUserTimeout !== 0) {
            writer.uint32(128).int32(message.tcpUserTimeout);
        }
        if (message.tcpMaxSeg !== 0) {
            writer.uint32(136).int32(message.tcpMaxSeg);
        }
        if (message.penetrate !== false) {
            writer.uint32(144).bool(message.penetrate);
        }
        if (message.tcpMptcp !== false) {
            writer.uint32(152).bool(message.tcpMptcp);
        }
        for (const v of message.customSockopt) {
            exports.CustomSockopt.encode(v, writer.uint32(162).fork()).join();
        }
        if (message.addressPortStrategy !== 0) {
            writer.uint32(168).int32(message.addressPortStrategy);
        }
        if (message.happyEyeballs !== undefined) {
            exports.HappyEyeballsConfig.encode(message.happyEyeballs, writer.uint32(178).fork()).join();
        }
        for (const v of message.trustedXForwardedFor) {
            writer.uint32(186).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSocketConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.mark = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.tfo = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.tproxy = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.receiveOriginalDestAddress = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.bindAddress = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.bindPort = reader.uint32();
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.acceptProxyProtocol = reader.bool();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.domainStrategy = reader.int32();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.dialerProxy = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.tcpKeepAliveInterval = reader.int32();
                    continue;
                }
                case 11: {
                    if (tag !== 88) {
                        break;
                    }
                    message.tcpKeepAliveIdle = reader.int32();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.tcpCongestion = reader.string();
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.interface = reader.string();
                    continue;
                }
                case 14: {
                    if (tag !== 112) {
                        break;
                    }
                    message.v6only = reader.bool();
                    continue;
                }
                case 15: {
                    if (tag !== 120) {
                        break;
                    }
                    message.tcpWindowClamp = reader.int32();
                    continue;
                }
                case 16: {
                    if (tag !== 128) {
                        break;
                    }
                    message.tcpUserTimeout = reader.int32();
                    continue;
                }
                case 17: {
                    if (tag !== 136) {
                        break;
                    }
                    message.tcpMaxSeg = reader.int32();
                    continue;
                }
                case 18: {
                    if (tag !== 144) {
                        break;
                    }
                    message.penetrate = reader.bool();
                    continue;
                }
                case 19: {
                    if (tag !== 152) {
                        break;
                    }
                    message.tcpMptcp = reader.bool();
                    continue;
                }
                case 20: {
                    if (tag !== 162) {
                        break;
                    }
                    message.customSockopt.push(exports.CustomSockopt.decode(reader, reader.uint32()));
                    continue;
                }
                case 21: {
                    if (tag !== 168) {
                        break;
                    }
                    message.addressPortStrategy = reader.int32();
                    continue;
                }
                case 22: {
                    if (tag !== 178) {
                        break;
                    }
                    message.happyEyeballs = exports.HappyEyeballsConfig.decode(reader, reader.uint32());
                    continue;
                }
                case 23: {
                    if (tag !== 186) {
                        break;
                    }
                    message.trustedXForwardedFor.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.SocketConfig.$type,
            mark: isSet(object.mark) ? globalThis.Number(object.mark) : 0,
            tfo: isSet(object.tfo) ? globalThis.Number(object.tfo) : 0,
            tproxy: isSet(object.tproxy) ? socketConfig_TProxyModeFromJSON(object.tproxy) : 0,
            receiveOriginalDestAddress: isSet(object.receiveOriginalDestAddress)
                ? globalThis.Boolean(object.receiveOriginalDestAddress)
                : false,
            bindAddress: isSet(object.bindAddress) ? bytesFromBase64(object.bindAddress) : new Uint8Array(0),
            bindPort: isSet(object.bindPort) ? globalThis.Number(object.bindPort) : 0,
            acceptProxyProtocol: isSet(object.acceptProxyProtocol) ? globalThis.Boolean(object.acceptProxyProtocol) : false,
            domainStrategy: isSet(object.domainStrategy) ? domainStrategyFromJSON(object.domainStrategy) : 0,
            dialerProxy: isSet(object.dialerProxy) ? globalThis.String(object.dialerProxy) : "",
            tcpKeepAliveInterval: isSet(object.tcpKeepAliveInterval) ? globalThis.Number(object.tcpKeepAliveInterval) : 0,
            tcpKeepAliveIdle: isSet(object.tcpKeepAliveIdle) ? globalThis.Number(object.tcpKeepAliveIdle) : 0,
            tcpCongestion: isSet(object.tcpCongestion) ? globalThis.String(object.tcpCongestion) : "",
            interface: isSet(object.interface) ? globalThis.String(object.interface) : "",
            v6only: isSet(object.v6only) ? globalThis.Boolean(object.v6only) : false,
            tcpWindowClamp: isSet(object.tcpWindowClamp) ? globalThis.Number(object.tcpWindowClamp) : 0,
            tcpUserTimeout: isSet(object.tcpUserTimeout) ? globalThis.Number(object.tcpUserTimeout) : 0,
            tcpMaxSeg: isSet(object.tcpMaxSeg) ? globalThis.Number(object.tcpMaxSeg) : 0,
            penetrate: isSet(object.penetrate) ? globalThis.Boolean(object.penetrate) : false,
            tcpMptcp: isSet(object.tcpMptcp) ? globalThis.Boolean(object.tcpMptcp) : false,
            customSockopt: globalThis.Array.isArray(object?.customSockopt)
                ? object.customSockopt.map((e) => exports.CustomSockopt.fromJSON(e))
                : [],
            addressPortStrategy: isSet(object.addressPortStrategy)
                ? addressPortStrategyFromJSON(object.addressPortStrategy)
                : 0,
            happyEyeballs: isSet(object.happyEyeballs) ? exports.HappyEyeballsConfig.fromJSON(object.happyEyeballs) : undefined,
            trustedXForwardedFor: globalThis.Array.isArray(object?.trustedXForwardedFor)
                ? object.trustedXForwardedFor.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mark !== 0) {
            obj.mark = Math.round(message.mark);
        }
        if (message.tfo !== 0) {
            obj.tfo = Math.round(message.tfo);
        }
        if (message.tproxy !== 0) {
            obj.tproxy = socketConfig_TProxyModeToJSON(message.tproxy);
        }
        if (message.receiveOriginalDestAddress !== false) {
            obj.receiveOriginalDestAddress = message.receiveOriginalDestAddress;
        }
        if (message.bindAddress.length !== 0) {
            obj.bindAddress = base64FromBytes(message.bindAddress);
        }
        if (message.bindPort !== 0) {
            obj.bindPort = Math.round(message.bindPort);
        }
        if (message.acceptProxyProtocol !== false) {
            obj.acceptProxyProtocol = message.acceptProxyProtocol;
        }
        if (message.domainStrategy !== 0) {
            obj.domainStrategy = domainStrategyToJSON(message.domainStrategy);
        }
        if (message.dialerProxy !== "") {
            obj.dialerProxy = message.dialerProxy;
        }
        if (message.tcpKeepAliveInterval !== 0) {
            obj.tcpKeepAliveInterval = Math.round(message.tcpKeepAliveInterval);
        }
        if (message.tcpKeepAliveIdle !== 0) {
            obj.tcpKeepAliveIdle = Math.round(message.tcpKeepAliveIdle);
        }
        if (message.tcpCongestion !== "") {
            obj.tcpCongestion = message.tcpCongestion;
        }
        if (message.interface !== "") {
            obj.interface = message.interface;
        }
        if (message.v6only !== false) {
            obj.v6only = message.v6only;
        }
        if (message.tcpWindowClamp !== 0) {
            obj.tcpWindowClamp = Math.round(message.tcpWindowClamp);
        }
        if (message.tcpUserTimeout !== 0) {
            obj.tcpUserTimeout = Math.round(message.tcpUserTimeout);
        }
        if (message.tcpMaxSeg !== 0) {
            obj.tcpMaxSeg = Math.round(message.tcpMaxSeg);
        }
        if (message.penetrate !== false) {
            obj.penetrate = message.penetrate;
        }
        if (message.tcpMptcp !== false) {
            obj.tcpMptcp = message.tcpMptcp;
        }
        if (message.customSockopt?.length) {
            obj.customSockopt = message.customSockopt.map((e) => exports.CustomSockopt.toJSON(e));
        }
        if (message.addressPortStrategy !== 0) {
            obj.addressPortStrategy = addressPortStrategyToJSON(message.addressPortStrategy);
        }
        if (message.happyEyeballs !== undefined) {
            obj.happyEyeballs = exports.HappyEyeballsConfig.toJSON(message.happyEyeballs);
        }
        if (message.trustedXForwardedFor?.length) {
            obj.trustedXForwardedFor = message.trustedXForwardedFor;
        }
        return obj;
    },
    create(base) {
        return exports.SocketConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSocketConfig();
        message.mark = object.mark ?? 0;
        message.tfo = object.tfo ?? 0;
        message.tproxy = object.tproxy ?? 0;
        message.receiveOriginalDestAddress = object.receiveOriginalDestAddress ?? false;
        message.bindAddress = object.bindAddress ?? new Uint8Array(0);
        message.bindPort = object.bindPort ?? 0;
        message.acceptProxyProtocol = object.acceptProxyProtocol ?? false;
        message.domainStrategy = object.domainStrategy ?? 0;
        message.dialerProxy = object.dialerProxy ?? "";
        message.tcpKeepAliveInterval = object.tcpKeepAliveInterval ?? 0;
        message.tcpKeepAliveIdle = object.tcpKeepAliveIdle ?? 0;
        message.tcpCongestion = object.tcpCongestion ?? "";
        message.interface = object.interface ?? "";
        message.v6only = object.v6only ?? false;
        message.tcpWindowClamp = object.tcpWindowClamp ?? 0;
        message.tcpUserTimeout = object.tcpUserTimeout ?? 0;
        message.tcpMaxSeg = object.tcpMaxSeg ?? 0;
        message.penetrate = object.penetrate ?? false;
        message.tcpMptcp = object.tcpMptcp ?? false;
        message.customSockopt = object.customSockopt?.map((e) => exports.CustomSockopt.fromPartial(e)) || [];
        message.addressPortStrategy = object.addressPortStrategy ?? 0;
        message.happyEyeballs = (object.happyEyeballs !== undefined && object.happyEyeballs !== null)
            ? exports.HappyEyeballsConfig.fromPartial(object.happyEyeballs)
            : undefined;
        message.trustedXForwardedFor = object.trustedXForwardedFor?.map((e) => e) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.SocketConfig.$type, exports.SocketConfig);
function createBaseHappyEyeballsConfig() {
    return {
        $type: "xray.transport.internet.HappyEyeballsConfig",
        prioritizeIpv6: false,
        interleave: 0,
        tryDelayMs: 0,
        maxConcurrentTry: 0,
    };
}
exports.HappyEyeballsConfig = {
    $type: "xray.transport.internet.HappyEyeballsConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.prioritizeIpv6 !== false) {
            writer.uint32(8).bool(message.prioritizeIpv6);
        }
        if (message.interleave !== 0) {
            writer.uint32(16).uint32(message.interleave);
        }
        if (message.tryDelayMs !== 0) {
            writer.uint32(24).uint64(message.tryDelayMs);
        }
        if (message.maxConcurrentTry !== 0) {
            writer.uint32(32).uint32(message.maxConcurrentTry);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHappyEyeballsConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.prioritizeIpv6 = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.interleave = reader.uint32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.tryDelayMs = longToNumber(reader.uint64());
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.maxConcurrentTry = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.HappyEyeballsConfig.$type,
            prioritizeIpv6: isSet(object.prioritizeIpv6) ? globalThis.Boolean(object.prioritizeIpv6) : false,
            interleave: isSet(object.interleave) ? globalThis.Number(object.interleave) : 0,
            tryDelayMs: isSet(object.tryDelayMs) ? globalThis.Number(object.tryDelayMs) : 0,
            maxConcurrentTry: isSet(object.maxConcurrentTry) ? globalThis.Number(object.maxConcurrentTry) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.prioritizeIpv6 !== false) {
            obj.prioritizeIpv6 = message.prioritizeIpv6;
        }
        if (message.interleave !== 0) {
            obj.interleave = Math.round(message.interleave);
        }
        if (message.tryDelayMs !== 0) {
            obj.tryDelayMs = Math.round(message.tryDelayMs);
        }
        if (message.maxConcurrentTry !== 0) {
            obj.maxConcurrentTry = Math.round(message.maxConcurrentTry);
        }
        return obj;
    },
    create(base) {
        return exports.HappyEyeballsConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHappyEyeballsConfig();
        message.prioritizeIpv6 = object.prioritizeIpv6 ?? false;
        message.interleave = object.interleave ?? 0;
        message.tryDelayMs = object.tryDelayMs ?? 0;
        message.maxConcurrentTry = object.maxConcurrentTry ?? 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.HappyEyeballsConfig.$type, exports.HappyEyeballsConfig);
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
