import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { IPOrDomain } from "../../common/net/address";
import { TypedMessage } from "../../common/serial/typed_message";
export declare const protobufPackage = "xray.transport.internet";
export declare enum DomainStrategy {
    AS_IS = 0,
    USE_IP = 1,
    USE_IP4 = 2,
    USE_IP6 = 3,
    USE_IP46 = 4,
    USE_IP64 = 5,
    FORCE_IP = 6,
    FORCE_IP4 = 7,
    FORCE_IP6 = 8,
    FORCE_IP46 = 9,
    FORCE_IP64 = 10,
    UNRECOGNIZED = -1
}
export declare function domainStrategyFromJSON(object: any): DomainStrategy;
export declare function domainStrategyToJSON(object: DomainStrategy): string;
export declare enum AddressPortStrategy {
    None = 0,
    SrvPortOnly = 1,
    SrvAddressOnly = 2,
    SrvPortAndAddress = 3,
    TxtPortOnly = 4,
    TxtAddressOnly = 5,
    TxtPortAndAddress = 6,
    UNRECOGNIZED = -1
}
export declare function addressPortStrategyFromJSON(object: any): AddressPortStrategy;
export declare function addressPortStrategyToJSON(object: AddressPortStrategy): string;
export interface TransportConfig {
    $type: "xray.transport.internet.TransportConfig";
    /** Transport protocol name. */
    protocolName: string;
    /** Specific transport protocol settings. */
    settings: TypedMessage | undefined;
}
export interface StreamConfig {
    $type: "xray.transport.internet.StreamConfig";
    address: IPOrDomain | undefined;
    port: number;
    /** Effective network. */
    protocolName: string;
    transportSettings: TransportConfig[];
    /** Type of security. Must be a message name of the settings proto. */
    securityType: string;
    /** Transport security settings. They can be either TLS or REALITY. */
    securitySettings: TypedMessage[];
    socketSettings: SocketConfig | undefined;
}
export interface ProxyConfig {
    $type: "xray.transport.internet.ProxyConfig";
    tag: string;
    transportLayerProxy: boolean;
}
export interface CustomSockopt {
    $type: "xray.transport.internet.CustomSockopt";
    system: string;
    network: string;
    level: string;
    opt: string;
    value: string;
    type: string;
}
/** SocketConfig is options to be applied on network sockets. */
export interface SocketConfig {
    $type: "xray.transport.internet.SocketConfig";
    /** Mark of the connection. If non-zero, the value will be set to SO_MARK. */
    mark: number;
    /** TFO is the state of TFO settings. */
    tfo: number;
    /** TProxy is for enabling TProxy socket option. */
    tproxy: SocketConfig_TProxyMode;
    /**
     * ReceiveOriginalDestAddress is for enabling IP_RECVORIGDSTADDR socket
     * option. This option is for UDP only.
     */
    receiveOriginalDestAddress: boolean;
    bindAddress: Uint8Array;
    bindPort: number;
    acceptProxyProtocol: boolean;
    domainStrategy: DomainStrategy;
    dialerProxy: string;
    tcpKeepAliveInterval: number;
    tcpKeepAliveIdle: number;
    tcpCongestion: string;
    interface: string;
    v6only: boolean;
    tcpWindowClamp: number;
    tcpUserTimeout: number;
    tcpMaxSeg: number;
    penetrate: boolean;
    tcpMptcp: boolean;
    customSockopt: CustomSockopt[];
    addressPortStrategy: AddressPortStrategy;
    happyEyeballs: HappyEyeballsConfig | undefined;
    trustedXForwardedFor: string[];
}
export declare enum SocketConfig_TProxyMode {
    /** Off - TProxy is off. */
    Off = 0,
    /** TProxy - TProxy mode. */
    TProxy = 1,
    /** Redirect - Redirect mode. */
    Redirect = 2,
    UNRECOGNIZED = -1
}
export declare function socketConfig_TProxyModeFromJSON(object: any): SocketConfig_TProxyMode;
export declare function socketConfig_TProxyModeToJSON(object: SocketConfig_TProxyMode): string;
export interface HappyEyeballsConfig {
    $type: "xray.transport.internet.HappyEyeballsConfig";
    prioritizeIpv6: boolean;
    interleave: number;
    tryDelayMs: number;
    maxConcurrentTry: number;
}
export declare const TransportConfig: MessageFns<TransportConfig, "xray.transport.internet.TransportConfig">;
export declare const StreamConfig: MessageFns<StreamConfig, "xray.transport.internet.StreamConfig">;
export declare const ProxyConfig: MessageFns<ProxyConfig, "xray.transport.internet.ProxyConfig">;
export declare const CustomSockopt: MessageFns<CustomSockopt, "xray.transport.internet.CustomSockopt">;
export declare const SocketConfig: MessageFns<SocketConfig, "xray.transport.internet.SocketConfig">;
export declare const HappyEyeballsConfig: MessageFns<HappyEyeballsConfig, "xray.transport.internet.HappyEyeballsConfig">;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T, V extends string> {
    readonly $type: V;
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=config.d.ts.map