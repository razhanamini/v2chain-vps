"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v5.29.3
// source: app/router/config.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = exports.StrategyLeastLoadConfig = exports.StrategyWeight = exports.BalancingRule = exports.RoutingRule_AttributesEntry = exports.RoutingRule = exports.GeoSiteList = exports.GeoSite = exports.GeoIPList = exports.GeoIP = exports.CIDR = exports.Domain_Attribute = exports.Domain = exports.Config_DomainStrategy = exports.Domain_Type = exports.protobufPackage = void 0;
exports.domain_TypeFromJSON = domain_TypeFromJSON;
exports.domain_TypeToJSON = domain_TypeToJSON;
exports.config_DomainStrategyFromJSON = config_DomainStrategyFromJSON;
exports.config_DomainStrategyToJSON = config_DomainStrategyToJSON;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const network_1 = require("../../common/net/network");
const port_1 = require("../../common/net/port");
const typed_message_1 = require("../../common/serial/typed_message");
const typeRegistry_1 = require("../../typeRegistry");
exports.protobufPackage = "xray.app.router";
/** Type of domain value. */
var Domain_Type;
(function (Domain_Type) {
    /** Plain - The value is used as is. */
    Domain_Type[Domain_Type["Plain"] = 0] = "Plain";
    /** Regex - The value is used as a regular expression. */
    Domain_Type[Domain_Type["Regex"] = 1] = "Regex";
    /** Domain - The value is a root domain. */
    Domain_Type[Domain_Type["Domain"] = 2] = "Domain";
    /** Full - The value is a domain. */
    Domain_Type[Domain_Type["Full"] = 3] = "Full";
    Domain_Type[Domain_Type["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Domain_Type || (exports.Domain_Type = Domain_Type = {}));
function domain_TypeFromJSON(object) {
    switch (object) {
        case 0:
        case "Plain":
            return Domain_Type.Plain;
        case 1:
        case "Regex":
            return Domain_Type.Regex;
        case 2:
        case "Domain":
            return Domain_Type.Domain;
        case 3:
        case "Full":
            return Domain_Type.Full;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Domain_Type.UNRECOGNIZED;
    }
}
function domain_TypeToJSON(object) {
    switch (object) {
        case Domain_Type.Plain:
            return "Plain";
        case Domain_Type.Regex:
            return "Regex";
        case Domain_Type.Domain:
            return "Domain";
        case Domain_Type.Full:
            return "Full";
        case Domain_Type.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var Config_DomainStrategy;
(function (Config_DomainStrategy) {
    /** AsIs - Use domain as is. */
    Config_DomainStrategy[Config_DomainStrategy["AsIs"] = 0] = "AsIs";
    /** IpIfNonMatch - Resolve to IP if the domain doesn't match any rules. */
    Config_DomainStrategy[Config_DomainStrategy["IpIfNonMatch"] = 2] = "IpIfNonMatch";
    /** IpOnDemand - Resolve to IP if any rule requires IP matching. */
    Config_DomainStrategy[Config_DomainStrategy["IpOnDemand"] = 3] = "IpOnDemand";
    Config_DomainStrategy[Config_DomainStrategy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Config_DomainStrategy || (exports.Config_DomainStrategy = Config_DomainStrategy = {}));
function config_DomainStrategyFromJSON(object) {
    switch (object) {
        case 0:
        case "AsIs":
            return Config_DomainStrategy.AsIs;
        case 2:
        case "IpIfNonMatch":
            return Config_DomainStrategy.IpIfNonMatch;
        case 3:
        case "IpOnDemand":
            return Config_DomainStrategy.IpOnDemand;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Config_DomainStrategy.UNRECOGNIZED;
    }
}
function config_DomainStrategyToJSON(object) {
    switch (object) {
        case Config_DomainStrategy.AsIs:
            return "AsIs";
        case Config_DomainStrategy.IpIfNonMatch:
            return "IpIfNonMatch";
        case Config_DomainStrategy.IpOnDemand:
            return "IpOnDemand";
        case Config_DomainStrategy.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseDomain() {
    return { $type: "xray.app.router.Domain", type: 0, value: "", attribute: [] };
}
exports.Domain = {
    $type: "xray.app.router.Domain",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        for (const v of message.attribute) {
            exports.Domain_Attribute.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDomain();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.attribute.push(exports.Domain_Attribute.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Domain.$type,
            type: isSet(object.type) ? domain_TypeFromJSON(object.type) : 0,
            value: isSet(object.value) ? globalThis.String(object.value) : "",
            attribute: globalThis.Array.isArray(object?.attribute)
                ? object.attribute.map((e) => exports.Domain_Attribute.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = domain_TypeToJSON(message.type);
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.attribute?.length) {
            obj.attribute = message.attribute.map((e) => exports.Domain_Attribute.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Domain.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDomain();
        message.type = object.type ?? 0;
        message.value = object.value ?? "";
        message.attribute = object.attribute?.map((e) => exports.Domain_Attribute.fromPartial(e)) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Domain.$type, exports.Domain);
function createBaseDomain_Attribute() {
    return { $type: "xray.app.router.Domain.Attribute", key: "", boolValue: undefined, intValue: undefined };
}
exports.Domain_Attribute = {
    $type: "xray.app.router.Domain.Attribute",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.boolValue !== undefined) {
            writer.uint32(16).bool(message.boolValue);
        }
        if (message.intValue !== undefined) {
            writer.uint32(24).int64(message.intValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDomain_Attribute();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.boolValue = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.intValue = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Domain_Attribute.$type,
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
            intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.boolValue !== undefined) {
            obj.boolValue = message.boolValue;
        }
        if (message.intValue !== undefined) {
            obj.intValue = Math.round(message.intValue);
        }
        return obj;
    },
    create(base) {
        return exports.Domain_Attribute.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDomain_Attribute();
        message.key = object.key ?? "";
        message.boolValue = object.boolValue ?? undefined;
        message.intValue = object.intValue ?? undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Domain_Attribute.$type, exports.Domain_Attribute);
function createBaseCIDR() {
    return { $type: "xray.app.router.CIDR", ip: new Uint8Array(0), prefix: 0 };
}
exports.CIDR = {
    $type: "xray.app.router.CIDR",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.ip.length !== 0) {
            writer.uint32(10).bytes(message.ip);
        }
        if (message.prefix !== 0) {
            writer.uint32(16).uint32(message.prefix);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCIDR();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ip = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.prefix = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.CIDR.$type,
            ip: isSet(object.ip) ? bytesFromBase64(object.ip) : new Uint8Array(0),
            prefix: isSet(object.prefix) ? globalThis.Number(object.prefix) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ip.length !== 0) {
            obj.ip = base64FromBytes(message.ip);
        }
        if (message.prefix !== 0) {
            obj.prefix = Math.round(message.prefix);
        }
        return obj;
    },
    create(base) {
        return exports.CIDR.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCIDR();
        message.ip = object.ip ?? new Uint8Array(0);
        message.prefix = object.prefix ?? 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.CIDR.$type, exports.CIDR);
function createBaseGeoIP() {
    return { $type: "xray.app.router.GeoIP", countryCode: "", cidr: [], reverseMatch: false };
}
exports.GeoIP = {
    $type: "xray.app.router.GeoIP",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.countryCode !== "") {
            writer.uint32(10).string(message.countryCode);
        }
        for (const v of message.cidr) {
            exports.CIDR.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.reverseMatch !== false) {
            writer.uint32(24).bool(message.reverseMatch);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGeoIP();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.countryCode = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.cidr.push(exports.CIDR.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.reverseMatch = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.GeoIP.$type,
            countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
            cidr: globalThis.Array.isArray(object?.cidr) ? object.cidr.map((e) => exports.CIDR.fromJSON(e)) : [],
            reverseMatch: isSet(object.reverseMatch) ? globalThis.Boolean(object.reverseMatch) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.countryCode !== "") {
            obj.countryCode = message.countryCode;
        }
        if (message.cidr?.length) {
            obj.cidr = message.cidr.map((e) => exports.CIDR.toJSON(e));
        }
        if (message.reverseMatch !== false) {
            obj.reverseMatch = message.reverseMatch;
        }
        return obj;
    },
    create(base) {
        return exports.GeoIP.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGeoIP();
        message.countryCode = object.countryCode ?? "";
        message.cidr = object.cidr?.map((e) => exports.CIDR.fromPartial(e)) || [];
        message.reverseMatch = object.reverseMatch ?? false;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.GeoIP.$type, exports.GeoIP);
function createBaseGeoIPList() {
    return { $type: "xray.app.router.GeoIPList", entry: [] };
}
exports.GeoIPList = {
    $type: "xray.app.router.GeoIPList",
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.entry) {
            exports.GeoIP.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGeoIPList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.entry.push(exports.GeoIP.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.GeoIPList.$type,
            entry: globalThis.Array.isArray(object?.entry) ? object.entry.map((e) => exports.GeoIP.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.entry?.length) {
            obj.entry = message.entry.map((e) => exports.GeoIP.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GeoIPList.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGeoIPList();
        message.entry = object.entry?.map((e) => exports.GeoIP.fromPartial(e)) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.GeoIPList.$type, exports.GeoIPList);
function createBaseGeoSite() {
    return { $type: "xray.app.router.GeoSite", countryCode: "", domain: [] };
}
exports.GeoSite = {
    $type: "xray.app.router.GeoSite",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.countryCode !== "") {
            writer.uint32(10).string(message.countryCode);
        }
        for (const v of message.domain) {
            exports.Domain.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGeoSite();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.countryCode = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.domain.push(exports.Domain.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.GeoSite.$type,
            countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
            domain: globalThis.Array.isArray(object?.domain) ? object.domain.map((e) => exports.Domain.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.countryCode !== "") {
            obj.countryCode = message.countryCode;
        }
        if (message.domain?.length) {
            obj.domain = message.domain.map((e) => exports.Domain.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GeoSite.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGeoSite();
        message.countryCode = object.countryCode ?? "";
        message.domain = object.domain?.map((e) => exports.Domain.fromPartial(e)) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.GeoSite.$type, exports.GeoSite);
function createBaseGeoSiteList() {
    return { $type: "xray.app.router.GeoSiteList", entry: [] };
}
exports.GeoSiteList = {
    $type: "xray.app.router.GeoSiteList",
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.entry) {
            exports.GeoSite.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGeoSiteList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.entry.push(exports.GeoSite.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.GeoSiteList.$type,
            entry: globalThis.Array.isArray(object?.entry) ? object.entry.map((e) => exports.GeoSite.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.entry?.length) {
            obj.entry = message.entry.map((e) => exports.GeoSite.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GeoSiteList.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGeoSiteList();
        message.entry = object.entry?.map((e) => exports.GeoSite.fromPartial(e)) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.GeoSiteList.$type, exports.GeoSiteList);
function createBaseRoutingRule() {
    return {
        $type: "xray.app.router.RoutingRule",
        tag: undefined,
        balancingTag: undefined,
        ruleTag: "",
        domain: [],
        geoip: [],
        portList: undefined,
        networks: [],
        sourceGeoip: [],
        sourcePortList: undefined,
        userEmail: [],
        inboundTag: [],
        protocol: [],
        attributes: {},
        localGeoip: [],
        localPortList: undefined,
        vlessRouteList: undefined,
    };
}
exports.RoutingRule = {
    $type: "xray.app.router.RoutingRule",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tag !== undefined) {
            writer.uint32(10).string(message.tag);
        }
        if (message.balancingTag !== undefined) {
            writer.uint32(98).string(message.balancingTag);
        }
        if (message.ruleTag !== "") {
            writer.uint32(154).string(message.ruleTag);
        }
        for (const v of message.domain) {
            exports.Domain.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.geoip) {
            exports.GeoIP.encode(v, writer.uint32(82).fork()).join();
        }
        if (message.portList !== undefined) {
            port_1.PortList.encode(message.portList, writer.uint32(114).fork()).join();
        }
        writer.uint32(106).fork();
        for (const v of message.networks) {
            writer.int32(v);
        }
        writer.join();
        for (const v of message.sourceGeoip) {
            exports.GeoIP.encode(v, writer.uint32(90).fork()).join();
        }
        if (message.sourcePortList !== undefined) {
            port_1.PortList.encode(message.sourcePortList, writer.uint32(130).fork()).join();
        }
        for (const v of message.userEmail) {
            writer.uint32(58).string(v);
        }
        for (const v of message.inboundTag) {
            writer.uint32(66).string(v);
        }
        for (const v of message.protocol) {
            writer.uint32(74).string(v);
        }
        Object.entries(message.attributes).forEach(([key, value]) => {
            exports.RoutingRule_AttributesEntry.encode({
                $type: "xray.app.router.RoutingRule.AttributesEntry",
                key: key,
                value,
            }, writer.uint32(122).fork()).join();
        });
        for (const v of message.localGeoip) {
            exports.GeoIP.encode(v, writer.uint32(138).fork()).join();
        }
        if (message.localPortList !== undefined) {
            port_1.PortList.encode(message.localPortList, writer.uint32(146).fork()).join();
        }
        if (message.vlessRouteList !== undefined) {
            port_1.PortList.encode(message.vlessRouteList, writer.uint32(162).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoutingRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tag = reader.string();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.balancingTag = reader.string();
                    continue;
                }
                case 19: {
                    if (tag !== 154) {
                        break;
                    }
                    message.ruleTag = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.domain.push(exports.Domain.decode(reader, reader.uint32()));
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.geoip.push(exports.GeoIP.decode(reader, reader.uint32()));
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.portList = port_1.PortList.decode(reader, reader.uint32());
                    continue;
                }
                case 13: {
                    if (tag === 104) {
                        message.networks.push(reader.int32());
                        continue;
                    }
                    if (tag === 106) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.networks.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.sourceGeoip.push(exports.GeoIP.decode(reader, reader.uint32()));
                    continue;
                }
                case 16: {
                    if (tag !== 130) {
                        break;
                    }
                    message.sourcePortList = port_1.PortList.decode(reader, reader.uint32());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.userEmail.push(reader.string());
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.inboundTag.push(reader.string());
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.protocol.push(reader.string());
                    continue;
                }
                case 15: {
                    if (tag !== 122) {
                        break;
                    }
                    const entry15 = exports.RoutingRule_AttributesEntry.decode(reader, reader.uint32());
                    if (entry15.value !== undefined) {
                        message.attributes[entry15.key] = entry15.value;
                    }
                    continue;
                }
                case 17: {
                    if (tag !== 138) {
                        break;
                    }
                    message.localGeoip.push(exports.GeoIP.decode(reader, reader.uint32()));
                    continue;
                }
                case 18: {
                    if (tag !== 146) {
                        break;
                    }
                    message.localPortList = port_1.PortList.decode(reader, reader.uint32());
                    continue;
                }
                case 20: {
                    if (tag !== 162) {
                        break;
                    }
                    message.vlessRouteList = port_1.PortList.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.RoutingRule.$type,
            tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
            balancingTag: isSet(object.balancingTag) ? globalThis.String(object.balancingTag) : undefined,
            ruleTag: isSet(object.ruleTag) ? globalThis.String(object.ruleTag) : "",
            domain: globalThis.Array.isArray(object?.domain) ? object.domain.map((e) => exports.Domain.fromJSON(e)) : [],
            geoip: globalThis.Array.isArray(object?.geoip) ? object.geoip.map((e) => exports.GeoIP.fromJSON(e)) : [],
            portList: isSet(object.portList) ? port_1.PortList.fromJSON(object.portList) : undefined,
            networks: globalThis.Array.isArray(object?.networks) ? object.networks.map((e) => (0, network_1.networkFromJSON)(e)) : [],
            sourceGeoip: globalThis.Array.isArray(object?.sourceGeoip)
                ? object.sourceGeoip.map((e) => exports.GeoIP.fromJSON(e))
                : [],
            sourcePortList: isSet(object.sourcePortList) ? port_1.PortList.fromJSON(object.sourcePortList) : undefined,
            userEmail: globalThis.Array.isArray(object?.userEmail)
                ? object.userEmail.map((e) => globalThis.String(e))
                : [],
            inboundTag: globalThis.Array.isArray(object?.inboundTag)
                ? object.inboundTag.map((e) => globalThis.String(e))
                : [],
            protocol: globalThis.Array.isArray(object?.protocol) ? object.protocol.map((e) => globalThis.String(e)) : [],
            attributes: isObject(object.attributes)
                ? Object.entries(object.attributes).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            localGeoip: globalThis.Array.isArray(object?.localGeoip)
                ? object.localGeoip.map((e) => exports.GeoIP.fromJSON(e))
                : [],
            localPortList: isSet(object.localPortList) ? port_1.PortList.fromJSON(object.localPortList) : undefined,
            vlessRouteList: isSet(object.vlessRouteList) ? port_1.PortList.fromJSON(object.vlessRouteList) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tag !== undefined) {
            obj.tag = message.tag;
        }
        if (message.balancingTag !== undefined) {
            obj.balancingTag = message.balancingTag;
        }
        if (message.ruleTag !== "") {
            obj.ruleTag = message.ruleTag;
        }
        if (message.domain?.length) {
            obj.domain = message.domain.map((e) => exports.Domain.toJSON(e));
        }
        if (message.geoip?.length) {
            obj.geoip = message.geoip.map((e) => exports.GeoIP.toJSON(e));
        }
        if (message.portList !== undefined) {
            obj.portList = port_1.PortList.toJSON(message.portList);
        }
        if (message.networks?.length) {
            obj.networks = message.networks.map((e) => (0, network_1.networkToJSON)(e));
        }
        if (message.sourceGeoip?.length) {
            obj.sourceGeoip = message.sourceGeoip.map((e) => exports.GeoIP.toJSON(e));
        }
        if (message.sourcePortList !== undefined) {
            obj.sourcePortList = port_1.PortList.toJSON(message.sourcePortList);
        }
        if (message.userEmail?.length) {
            obj.userEmail = message.userEmail;
        }
        if (message.inboundTag?.length) {
            obj.inboundTag = message.inboundTag;
        }
        if (message.protocol?.length) {
            obj.protocol = message.protocol;
        }
        if (message.attributes) {
            const entries = Object.entries(message.attributes);
            if (entries.length > 0) {
                obj.attributes = {};
                entries.forEach(([k, v]) => {
                    obj.attributes[k] = v;
                });
            }
        }
        if (message.localGeoip?.length) {
            obj.localGeoip = message.localGeoip.map((e) => exports.GeoIP.toJSON(e));
        }
        if (message.localPortList !== undefined) {
            obj.localPortList = port_1.PortList.toJSON(message.localPortList);
        }
        if (message.vlessRouteList !== undefined) {
            obj.vlessRouteList = port_1.PortList.toJSON(message.vlessRouteList);
        }
        return obj;
    },
    create(base) {
        return exports.RoutingRule.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRoutingRule();
        message.tag = object.tag ?? undefined;
        message.balancingTag = object.balancingTag ?? undefined;
        message.ruleTag = object.ruleTag ?? "";
        message.domain = object.domain?.map((e) => exports.Domain.fromPartial(e)) || [];
        message.geoip = object.geoip?.map((e) => exports.GeoIP.fromPartial(e)) || [];
        message.portList = (object.portList !== undefined && object.portList !== null)
            ? port_1.PortList.fromPartial(object.portList)
            : undefined;
        message.networks = object.networks?.map((e) => e) || [];
        message.sourceGeoip = object.sourceGeoip?.map((e) => exports.GeoIP.fromPartial(e)) || [];
        message.sourcePortList = (object.sourcePortList !== undefined && object.sourcePortList !== null)
            ? port_1.PortList.fromPartial(object.sourcePortList)
            : undefined;
        message.userEmail = object.userEmail?.map((e) => e) || [];
        message.inboundTag = object.inboundTag?.map((e) => e) || [];
        message.protocol = object.protocol?.map((e) => e) || [];
        message.attributes = Object.entries(object.attributes ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.localGeoip = object.localGeoip?.map((e) => exports.GeoIP.fromPartial(e)) || [];
        message.localPortList = (object.localPortList !== undefined && object.localPortList !== null)
            ? port_1.PortList.fromPartial(object.localPortList)
            : undefined;
        message.vlessRouteList = (object.vlessRouteList !== undefined && object.vlessRouteList !== null)
            ? port_1.PortList.fromPartial(object.vlessRouteList)
            : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RoutingRule.$type, exports.RoutingRule);
function createBaseRoutingRule_AttributesEntry() {
    return { $type: "xray.app.router.RoutingRule.AttributesEntry", key: "", value: "" };
}
exports.RoutingRule_AttributesEntry = {
    $type: "xray.app.router.RoutingRule.AttributesEntry",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoutingRule_AttributesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.RoutingRule_AttributesEntry.$type,
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.RoutingRule_AttributesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRoutingRule_AttributesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RoutingRule_AttributesEntry.$type, exports.RoutingRule_AttributesEntry);
function createBaseBalancingRule() {
    return {
        $type: "xray.app.router.BalancingRule",
        tag: "",
        outboundSelector: [],
        strategy: "",
        strategySettings: undefined,
        fallbackTag: "",
    };
}
exports.BalancingRule = {
    $type: "xray.app.router.BalancingRule",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tag !== "") {
            writer.uint32(10).string(message.tag);
        }
        for (const v of message.outboundSelector) {
            writer.uint32(18).string(v);
        }
        if (message.strategy !== "") {
            writer.uint32(26).string(message.strategy);
        }
        if (message.strategySettings !== undefined) {
            typed_message_1.TypedMessage.encode(message.strategySettings, writer.uint32(34).fork()).join();
        }
        if (message.fallbackTag !== "") {
            writer.uint32(42).string(message.fallbackTag);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBalancingRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tag = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.outboundSelector.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.strategy = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.strategySettings = typed_message_1.TypedMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.fallbackTag = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.BalancingRule.$type,
            tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
            outboundSelector: globalThis.Array.isArray(object?.outboundSelector)
                ? object.outboundSelector.map((e) => globalThis.String(e))
                : [],
            strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
            strategySettings: isSet(object.strategySettings) ? typed_message_1.TypedMessage.fromJSON(object.strategySettings) : undefined,
            fallbackTag: isSet(object.fallbackTag) ? globalThis.String(object.fallbackTag) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tag !== "") {
            obj.tag = message.tag;
        }
        if (message.outboundSelector?.length) {
            obj.outboundSelector = message.outboundSelector;
        }
        if (message.strategy !== "") {
            obj.strategy = message.strategy;
        }
        if (message.strategySettings !== undefined) {
            obj.strategySettings = typed_message_1.TypedMessage.toJSON(message.strategySettings);
        }
        if (message.fallbackTag !== "") {
            obj.fallbackTag = message.fallbackTag;
        }
        return obj;
    },
    create(base) {
        return exports.BalancingRule.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBalancingRule();
        message.tag = object.tag ?? "";
        message.outboundSelector = object.outboundSelector?.map((e) => e) || [];
        message.strategy = object.strategy ?? "";
        message.strategySettings = (object.strategySettings !== undefined && object.strategySettings !== null)
            ? typed_message_1.TypedMessage.fromPartial(object.strategySettings)
            : undefined;
        message.fallbackTag = object.fallbackTag ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.BalancingRule.$type, exports.BalancingRule);
function createBaseStrategyWeight() {
    return { $type: "xray.app.router.StrategyWeight", regexp: false, match: "", value: 0 };
}
exports.StrategyWeight = {
    $type: "xray.app.router.StrategyWeight",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.regexp !== false) {
            writer.uint32(8).bool(message.regexp);
        }
        if (message.match !== "") {
            writer.uint32(18).string(message.match);
        }
        if (message.value !== 0) {
            writer.uint32(29).float(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStrategyWeight();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.regexp = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.match = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 29) {
                        break;
                    }
                    message.value = reader.float();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.StrategyWeight.$type,
            regexp: isSet(object.regexp) ? globalThis.Boolean(object.regexp) : false,
            match: isSet(object.match) ? globalThis.String(object.match) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.regexp !== false) {
            obj.regexp = message.regexp;
        }
        if (message.match !== "") {
            obj.match = message.match;
        }
        if (message.value !== 0) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.StrategyWeight.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStrategyWeight();
        message.regexp = object.regexp ?? false;
        message.match = object.match ?? "";
        message.value = object.value ?? 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.StrategyWeight.$type, exports.StrategyWeight);
function createBaseStrategyLeastLoadConfig() {
    return {
        $type: "xray.app.router.StrategyLeastLoadConfig",
        costs: [],
        baselines: [],
        expected: 0,
        maxRTT: 0,
        tolerance: 0,
    };
}
exports.StrategyLeastLoadConfig = {
    $type: "xray.app.router.StrategyLeastLoadConfig",
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.costs) {
            exports.StrategyWeight.encode(v, writer.uint32(18).fork()).join();
        }
        writer.uint32(26).fork();
        for (const v of message.baselines) {
            writer.int64(v);
        }
        writer.join();
        if (message.expected !== 0) {
            writer.uint32(32).int32(message.expected);
        }
        if (message.maxRTT !== 0) {
            writer.uint32(40).int64(message.maxRTT);
        }
        if (message.tolerance !== 0) {
            writer.uint32(53).float(message.tolerance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStrategyLeastLoadConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.costs.push(exports.StrategyWeight.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag === 24) {
                        message.baselines.push(longToNumber(reader.int64()));
                        continue;
                    }
                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.baselines.push(longToNumber(reader.int64()));
                        }
                        continue;
                    }
                    break;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.expected = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.maxRTT = longToNumber(reader.int64());
                    continue;
                }
                case 6: {
                    if (tag !== 53) {
                        break;
                    }
                    message.tolerance = reader.float();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.StrategyLeastLoadConfig.$type,
            costs: globalThis.Array.isArray(object?.costs) ? object.costs.map((e) => exports.StrategyWeight.fromJSON(e)) : [],
            baselines: globalThis.Array.isArray(object?.baselines)
                ? object.baselines.map((e) => globalThis.Number(e))
                : [],
            expected: isSet(object.expected) ? globalThis.Number(object.expected) : 0,
            maxRTT: isSet(object.maxRTT) ? globalThis.Number(object.maxRTT) : 0,
            tolerance: isSet(object.tolerance) ? globalThis.Number(object.tolerance) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.costs?.length) {
            obj.costs = message.costs.map((e) => exports.StrategyWeight.toJSON(e));
        }
        if (message.baselines?.length) {
            obj.baselines = message.baselines.map((e) => Math.round(e));
        }
        if (message.expected !== 0) {
            obj.expected = Math.round(message.expected);
        }
        if (message.maxRTT !== 0) {
            obj.maxRTT = Math.round(message.maxRTT);
        }
        if (message.tolerance !== 0) {
            obj.tolerance = message.tolerance;
        }
        return obj;
    },
    create(base) {
        return exports.StrategyLeastLoadConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStrategyLeastLoadConfig();
        message.costs = object.costs?.map((e) => exports.StrategyWeight.fromPartial(e)) || [];
        message.baselines = object.baselines?.map((e) => e) || [];
        message.expected = object.expected ?? 0;
        message.maxRTT = object.maxRTT ?? 0;
        message.tolerance = object.tolerance ?? 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.StrategyLeastLoadConfig.$type, exports.StrategyLeastLoadConfig);
function createBaseConfig() {
    return { $type: "xray.app.router.Config", domainStrategy: 0, rule: [], balancingRule: [] };
}
exports.Config = {
    $type: "xray.app.router.Config",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.domainStrategy !== 0) {
            writer.uint32(8).int32(message.domainStrategy);
        }
        for (const v of message.rule) {
            exports.RoutingRule.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.balancingRule) {
            exports.BalancingRule.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.domainStrategy = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.rule.push(exports.RoutingRule.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.balancingRule.push(exports.BalancingRule.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Config.$type,
            domainStrategy: isSet(object.domainStrategy) ? config_DomainStrategyFromJSON(object.domainStrategy) : 0,
            rule: globalThis.Array.isArray(object?.rule) ? object.rule.map((e) => exports.RoutingRule.fromJSON(e)) : [],
            balancingRule: globalThis.Array.isArray(object?.balancingRule)
                ? object.balancingRule.map((e) => exports.BalancingRule.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.domainStrategy !== 0) {
            obj.domainStrategy = config_DomainStrategyToJSON(message.domainStrategy);
        }
        if (message.rule?.length) {
            obj.rule = message.rule.map((e) => exports.RoutingRule.toJSON(e));
        }
        if (message.balancingRule?.length) {
            obj.balancingRule = message.balancingRule.map((e) => exports.BalancingRule.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Config.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConfig();
        message.domainStrategy = object.domainStrategy ?? 0;
        message.rule = object.rule?.map((e) => exports.RoutingRule.fromPartial(e)) || [];
        message.balancingRule = object.balancingRule?.map((e) => exports.BalancingRule.fromPartial(e)) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Config.$type, exports.Config);
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
