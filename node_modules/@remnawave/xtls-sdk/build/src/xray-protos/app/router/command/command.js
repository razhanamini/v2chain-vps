"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v5.29.3
// source: app/router/command/command.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoutingServiceDefinition = exports.Config = exports.RemoveRuleResponse = exports.RemoveRuleRequest = exports.AddRuleResponse = exports.AddRuleRequest = exports.OverrideBalancerTargetResponse = exports.OverrideBalancerTargetRequest = exports.GetBalancerInfoResponse = exports.GetBalancerInfoRequest = exports.BalancerMsg = exports.OverrideInfo = exports.PrincipleTargetInfo = exports.TestRouteRequest = exports.SubscribeRoutingStatsRequest = exports.RoutingContext_AttributesEntry = exports.RoutingContext = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const network_1 = require("../../../common/net/network");
const typed_message_1 = require("../../../common/serial/typed_message");
const typeRegistry_1 = require("../../../typeRegistry");
exports.protobufPackage = "xray.app.router.command";
function createBaseRoutingContext() {
    return {
        $type: "xray.app.router.command.RoutingContext",
        InboundTag: "",
        Network: 0,
        SourceIPs: [],
        TargetIPs: [],
        SourcePort: 0,
        TargetPort: 0,
        TargetDomain: "",
        Protocol: "",
        User: "",
        Attributes: {},
        OutboundGroupTags: [],
        OutboundTag: "",
        LocalIPs: [],
        LocalPort: 0,
        VlessRoute: 0,
    };
}
exports.RoutingContext = {
    $type: "xray.app.router.command.RoutingContext",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.InboundTag !== "") {
            writer.uint32(10).string(message.InboundTag);
        }
        if (message.Network !== 0) {
            writer.uint32(16).int32(message.Network);
        }
        for (const v of message.SourceIPs) {
            writer.uint32(26).bytes(v);
        }
        for (const v of message.TargetIPs) {
            writer.uint32(34).bytes(v);
        }
        if (message.SourcePort !== 0) {
            writer.uint32(40).uint32(message.SourcePort);
        }
        if (message.TargetPort !== 0) {
            writer.uint32(48).uint32(message.TargetPort);
        }
        if (message.TargetDomain !== "") {
            writer.uint32(58).string(message.TargetDomain);
        }
        if (message.Protocol !== "") {
            writer.uint32(66).string(message.Protocol);
        }
        if (message.User !== "") {
            writer.uint32(74).string(message.User);
        }
        Object.entries(message.Attributes).forEach(([key, value]) => {
            exports.RoutingContext_AttributesEntry.encode({
                $type: "xray.app.router.command.RoutingContext.AttributesEntry",
                key: key,
                value,
            }, writer.uint32(82).fork()).join();
        });
        for (const v of message.OutboundGroupTags) {
            writer.uint32(90).string(v);
        }
        if (message.OutboundTag !== "") {
            writer.uint32(98).string(message.OutboundTag);
        }
        for (const v of message.LocalIPs) {
            writer.uint32(106).bytes(v);
        }
        if (message.LocalPort !== 0) {
            writer.uint32(112).uint32(message.LocalPort);
        }
        if (message.VlessRoute !== 0) {
            writer.uint32(120).uint32(message.VlessRoute);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoutingContext();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.InboundTag = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.Network = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.SourceIPs.push(reader.bytes());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.TargetIPs.push(reader.bytes());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.SourcePort = reader.uint32();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.TargetPort = reader.uint32();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.TargetDomain = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.Protocol = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.User = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    const entry10 = exports.RoutingContext_AttributesEntry.decode(reader, reader.uint32());
                    if (entry10.value !== undefined) {
                        message.Attributes[entry10.key] = entry10.value;
                    }
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.OutboundGroupTags.push(reader.string());
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.OutboundTag = reader.string();
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.LocalIPs.push(reader.bytes());
                    continue;
                }
                case 14: {
                    if (tag !== 112) {
                        break;
                    }
                    message.LocalPort = reader.uint32();
                    continue;
                }
                case 15: {
                    if (tag !== 120) {
                        break;
                    }
                    message.VlessRoute = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.RoutingContext.$type,
            InboundTag: isSet(object.InboundTag) ? globalThis.String(object.InboundTag) : "",
            Network: isSet(object.Network) ? (0, network_1.networkFromJSON)(object.Network) : 0,
            SourceIPs: globalThis.Array.isArray(object?.SourceIPs)
                ? object.SourceIPs.map((e) => bytesFromBase64(e))
                : [],
            TargetIPs: globalThis.Array.isArray(object?.TargetIPs)
                ? object.TargetIPs.map((e) => bytesFromBase64(e))
                : [],
            SourcePort: isSet(object.SourcePort) ? globalThis.Number(object.SourcePort) : 0,
            TargetPort: isSet(object.TargetPort) ? globalThis.Number(object.TargetPort) : 0,
            TargetDomain: isSet(object.TargetDomain) ? globalThis.String(object.TargetDomain) : "",
            Protocol: isSet(object.Protocol) ? globalThis.String(object.Protocol) : "",
            User: isSet(object.User) ? globalThis.String(object.User) : "",
            Attributes: isObject(object.Attributes)
                ? Object.entries(object.Attributes).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            OutboundGroupTags: globalThis.Array.isArray(object?.OutboundGroupTags)
                ? object.OutboundGroupTags.map((e) => globalThis.String(e))
                : [],
            OutboundTag: isSet(object.OutboundTag) ? globalThis.String(object.OutboundTag) : "",
            LocalIPs: globalThis.Array.isArray(object?.LocalIPs) ? object.LocalIPs.map((e) => bytesFromBase64(e)) : [],
            LocalPort: isSet(object.LocalPort) ? globalThis.Number(object.LocalPort) : 0,
            VlessRoute: isSet(object.VlessRoute) ? globalThis.Number(object.VlessRoute) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.InboundTag !== "") {
            obj.InboundTag = message.InboundTag;
        }
        if (message.Network !== 0) {
            obj.Network = (0, network_1.networkToJSON)(message.Network);
        }
        if (message.SourceIPs?.length) {
            obj.SourceIPs = message.SourceIPs.map((e) => base64FromBytes(e));
        }
        if (message.TargetIPs?.length) {
            obj.TargetIPs = message.TargetIPs.map((e) => base64FromBytes(e));
        }
        if (message.SourcePort !== 0) {
            obj.SourcePort = Math.round(message.SourcePort);
        }
        if (message.TargetPort !== 0) {
            obj.TargetPort = Math.round(message.TargetPort);
        }
        if (message.TargetDomain !== "") {
            obj.TargetDomain = message.TargetDomain;
        }
        if (message.Protocol !== "") {
            obj.Protocol = message.Protocol;
        }
        if (message.User !== "") {
            obj.User = message.User;
        }
        if (message.Attributes) {
            const entries = Object.entries(message.Attributes);
            if (entries.length > 0) {
                obj.Attributes = {};
                entries.forEach(([k, v]) => {
                    obj.Attributes[k] = v;
                });
            }
        }
        if (message.OutboundGroupTags?.length) {
            obj.OutboundGroupTags = message.OutboundGroupTags;
        }
        if (message.OutboundTag !== "") {
            obj.OutboundTag = message.OutboundTag;
        }
        if (message.LocalIPs?.length) {
            obj.LocalIPs = message.LocalIPs.map((e) => base64FromBytes(e));
        }
        if (message.LocalPort !== 0) {
            obj.LocalPort = Math.round(message.LocalPort);
        }
        if (message.VlessRoute !== 0) {
            obj.VlessRoute = Math.round(message.VlessRoute);
        }
        return obj;
    },
    create(base) {
        return exports.RoutingContext.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRoutingContext();
        message.InboundTag = object.InboundTag ?? "";
        message.Network = object.Network ?? 0;
        message.SourceIPs = object.SourceIPs?.map((e) => e) || [];
        message.TargetIPs = object.TargetIPs?.map((e) => e) || [];
        message.SourcePort = object.SourcePort ?? 0;
        message.TargetPort = object.TargetPort ?? 0;
        message.TargetDomain = object.TargetDomain ?? "";
        message.Protocol = object.Protocol ?? "";
        message.User = object.User ?? "";
        message.Attributes = Object.entries(object.Attributes ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.OutboundGroupTags = object.OutboundGroupTags?.map((e) => e) || [];
        message.OutboundTag = object.OutboundTag ?? "";
        message.LocalIPs = object.LocalIPs?.map((e) => e) || [];
        message.LocalPort = object.LocalPort ?? 0;
        message.VlessRoute = object.VlessRoute ?? 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RoutingContext.$type, exports.RoutingContext);
function createBaseRoutingContext_AttributesEntry() {
    return { $type: "xray.app.router.command.RoutingContext.AttributesEntry", key: "", value: "" };
}
exports.RoutingContext_AttributesEntry = {
    $type: "xray.app.router.command.RoutingContext.AttributesEntry",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoutingContext_AttributesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.RoutingContext_AttributesEntry.$type,
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.RoutingContext_AttributesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRoutingContext_AttributesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RoutingContext_AttributesEntry.$type, exports.RoutingContext_AttributesEntry);
function createBaseSubscribeRoutingStatsRequest() {
    return { $type: "xray.app.router.command.SubscribeRoutingStatsRequest", FieldSelectors: [] };
}
exports.SubscribeRoutingStatsRequest = {
    $type: "xray.app.router.command.SubscribeRoutingStatsRequest",
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.FieldSelectors) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeRoutingStatsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.FieldSelectors.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.SubscribeRoutingStatsRequest.$type,
            FieldSelectors: globalThis.Array.isArray(object?.FieldSelectors)
                ? object.FieldSelectors.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.FieldSelectors?.length) {
            obj.FieldSelectors = message.FieldSelectors;
        }
        return obj;
    },
    create(base) {
        return exports.SubscribeRoutingStatsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubscribeRoutingStatsRequest();
        message.FieldSelectors = object.FieldSelectors?.map((e) => e) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.SubscribeRoutingStatsRequest.$type, exports.SubscribeRoutingStatsRequest);
function createBaseTestRouteRequest() {
    return {
        $type: "xray.app.router.command.TestRouteRequest",
        RoutingContext: undefined,
        FieldSelectors: [],
        PublishResult: false,
    };
}
exports.TestRouteRequest = {
    $type: "xray.app.router.command.TestRouteRequest",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.RoutingContext !== undefined) {
            exports.RoutingContext.encode(message.RoutingContext, writer.uint32(10).fork()).join();
        }
        for (const v of message.FieldSelectors) {
            writer.uint32(18).string(v);
        }
        if (message.PublishResult !== false) {
            writer.uint32(24).bool(message.PublishResult);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTestRouteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.RoutingContext = exports.RoutingContext.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.FieldSelectors.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.PublishResult = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.TestRouteRequest.$type,
            RoutingContext: isSet(object.RoutingContext) ? exports.RoutingContext.fromJSON(object.RoutingContext) : undefined,
            FieldSelectors: globalThis.Array.isArray(object?.FieldSelectors)
                ? object.FieldSelectors.map((e) => globalThis.String(e))
                : [],
            PublishResult: isSet(object.PublishResult) ? globalThis.Boolean(object.PublishResult) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.RoutingContext !== undefined) {
            obj.RoutingContext = exports.RoutingContext.toJSON(message.RoutingContext);
        }
        if (message.FieldSelectors?.length) {
            obj.FieldSelectors = message.FieldSelectors;
        }
        if (message.PublishResult !== false) {
            obj.PublishResult = message.PublishResult;
        }
        return obj;
    },
    create(base) {
        return exports.TestRouteRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTestRouteRequest();
        message.RoutingContext = (object.RoutingContext !== undefined && object.RoutingContext !== null)
            ? exports.RoutingContext.fromPartial(object.RoutingContext)
            : undefined;
        message.FieldSelectors = object.FieldSelectors?.map((e) => e) || [];
        message.PublishResult = object.PublishResult ?? false;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.TestRouteRequest.$type, exports.TestRouteRequest);
function createBasePrincipleTargetInfo() {
    return { $type: "xray.app.router.command.PrincipleTargetInfo", tag: [] };
}
exports.PrincipleTargetInfo = {
    $type: "xray.app.router.command.PrincipleTargetInfo",
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.tag) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipleTargetInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tag.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.PrincipleTargetInfo.$type,
            tag: globalThis.Array.isArray(object?.tag) ? object.tag.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tag?.length) {
            obj.tag = message.tag;
        }
        return obj;
    },
    create(base) {
        return exports.PrincipleTargetInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePrincipleTargetInfo();
        message.tag = object.tag?.map((e) => e) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.PrincipleTargetInfo.$type, exports.PrincipleTargetInfo);
function createBaseOverrideInfo() {
    return { $type: "xray.app.router.command.OverrideInfo", target: "" };
}
exports.OverrideInfo = {
    $type: "xray.app.router.command.OverrideInfo",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.target !== "") {
            writer.uint32(18).string(message.target);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOverrideInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.target = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { $type: exports.OverrideInfo.$type, target: isSet(object.target) ? globalThis.String(object.target) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.target !== "") {
            obj.target = message.target;
        }
        return obj;
    },
    create(base) {
        return exports.OverrideInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOverrideInfo();
        message.target = object.target ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.OverrideInfo.$type, exports.OverrideInfo);
function createBaseBalancerMsg() {
    return { $type: "xray.app.router.command.BalancerMsg", override: undefined, principleTarget: undefined };
}
exports.BalancerMsg = {
    $type: "xray.app.router.command.BalancerMsg",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.override !== undefined) {
            exports.OverrideInfo.encode(message.override, writer.uint32(42).fork()).join();
        }
        if (message.principleTarget !== undefined) {
            exports.PrincipleTargetInfo.encode(message.principleTarget, writer.uint32(50).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBalancerMsg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.override = exports.OverrideInfo.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.principleTarget = exports.PrincipleTargetInfo.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.BalancerMsg.$type,
            override: isSet(object.override) ? exports.OverrideInfo.fromJSON(object.override) : undefined,
            principleTarget: isSet(object.principleTarget) ? exports.PrincipleTargetInfo.fromJSON(object.principleTarget) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.override !== undefined) {
            obj.override = exports.OverrideInfo.toJSON(message.override);
        }
        if (message.principleTarget !== undefined) {
            obj.principleTarget = exports.PrincipleTargetInfo.toJSON(message.principleTarget);
        }
        return obj;
    },
    create(base) {
        return exports.BalancerMsg.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBalancerMsg();
        message.override = (object.override !== undefined && object.override !== null)
            ? exports.OverrideInfo.fromPartial(object.override)
            : undefined;
        message.principleTarget = (object.principleTarget !== undefined && object.principleTarget !== null)
            ? exports.PrincipleTargetInfo.fromPartial(object.principleTarget)
            : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.BalancerMsg.$type, exports.BalancerMsg);
function createBaseGetBalancerInfoRequest() {
    return { $type: "xray.app.router.command.GetBalancerInfoRequest", tag: "" };
}
exports.GetBalancerInfoRequest = {
    $type: "xray.app.router.command.GetBalancerInfoRequest",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tag !== "") {
            writer.uint32(10).string(message.tag);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetBalancerInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tag = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { $type: exports.GetBalancerInfoRequest.$type, tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.tag !== "") {
            obj.tag = message.tag;
        }
        return obj;
    },
    create(base) {
        return exports.GetBalancerInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetBalancerInfoRequest();
        message.tag = object.tag ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.GetBalancerInfoRequest.$type, exports.GetBalancerInfoRequest);
function createBaseGetBalancerInfoResponse() {
    return { $type: "xray.app.router.command.GetBalancerInfoResponse", balancer: undefined };
}
exports.GetBalancerInfoResponse = {
    $type: "xray.app.router.command.GetBalancerInfoResponse",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.balancer !== undefined) {
            exports.BalancerMsg.encode(message.balancer, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetBalancerInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.balancer = exports.BalancerMsg.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.GetBalancerInfoResponse.$type,
            balancer: isSet(object.balancer) ? exports.BalancerMsg.fromJSON(object.balancer) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.balancer !== undefined) {
            obj.balancer = exports.BalancerMsg.toJSON(message.balancer);
        }
        return obj;
    },
    create(base) {
        return exports.GetBalancerInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetBalancerInfoResponse();
        message.balancer = (object.balancer !== undefined && object.balancer !== null)
            ? exports.BalancerMsg.fromPartial(object.balancer)
            : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.GetBalancerInfoResponse.$type, exports.GetBalancerInfoResponse);
function createBaseOverrideBalancerTargetRequest() {
    return { $type: "xray.app.router.command.OverrideBalancerTargetRequest", balancerTag: "", target: "" };
}
exports.OverrideBalancerTargetRequest = {
    $type: "xray.app.router.command.OverrideBalancerTargetRequest",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.balancerTag !== "") {
            writer.uint32(10).string(message.balancerTag);
        }
        if (message.target !== "") {
            writer.uint32(18).string(message.target);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOverrideBalancerTargetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.balancerTag = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.target = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.OverrideBalancerTargetRequest.$type,
            balancerTag: isSet(object.balancerTag) ? globalThis.String(object.balancerTag) : "",
            target: isSet(object.target) ? globalThis.String(object.target) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.balancerTag !== "") {
            obj.balancerTag = message.balancerTag;
        }
        if (message.target !== "") {
            obj.target = message.target;
        }
        return obj;
    },
    create(base) {
        return exports.OverrideBalancerTargetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOverrideBalancerTargetRequest();
        message.balancerTag = object.balancerTag ?? "";
        message.target = object.target ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.OverrideBalancerTargetRequest.$type, exports.OverrideBalancerTargetRequest);
function createBaseOverrideBalancerTargetResponse() {
    return { $type: "xray.app.router.command.OverrideBalancerTargetResponse" };
}
exports.OverrideBalancerTargetResponse = {
    $type: "xray.app.router.command.OverrideBalancerTargetResponse",
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOverrideBalancerTargetResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return { $type: exports.OverrideBalancerTargetResponse.$type };
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.OverrideBalancerTargetResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseOverrideBalancerTargetResponse();
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.OverrideBalancerTargetResponse.$type, exports.OverrideBalancerTargetResponse);
function createBaseAddRuleRequest() {
    return { $type: "xray.app.router.command.AddRuleRequest", config: undefined, shouldAppend: false };
}
exports.AddRuleRequest = {
    $type: "xray.app.router.command.AddRuleRequest",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.config !== undefined) {
            typed_message_1.TypedMessage.encode(message.config, writer.uint32(10).fork()).join();
        }
        if (message.shouldAppend !== false) {
            writer.uint32(16).bool(message.shouldAppend);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddRuleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.config = typed_message_1.TypedMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.shouldAppend = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.AddRuleRequest.$type,
            config: isSet(object.config) ? typed_message_1.TypedMessage.fromJSON(object.config) : undefined,
            shouldAppend: isSet(object.shouldAppend) ? globalThis.Boolean(object.shouldAppend) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.config !== undefined) {
            obj.config = typed_message_1.TypedMessage.toJSON(message.config);
        }
        if (message.shouldAppend !== false) {
            obj.shouldAppend = message.shouldAppend;
        }
        return obj;
    },
    create(base) {
        return exports.AddRuleRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddRuleRequest();
        message.config = (object.config !== undefined && object.config !== null)
            ? typed_message_1.TypedMessage.fromPartial(object.config)
            : undefined;
        message.shouldAppend = object.shouldAppend ?? false;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.AddRuleRequest.$type, exports.AddRuleRequest);
function createBaseAddRuleResponse() {
    return { $type: "xray.app.router.command.AddRuleResponse" };
}
exports.AddRuleResponse = {
    $type: "xray.app.router.command.AddRuleResponse",
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddRuleResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return { $type: exports.AddRuleResponse.$type };
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.AddRuleResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseAddRuleResponse();
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.AddRuleResponse.$type, exports.AddRuleResponse);
function createBaseRemoveRuleRequest() {
    return { $type: "xray.app.router.command.RemoveRuleRequest", ruleTag: "" };
}
exports.RemoveRuleRequest = {
    $type: "xray.app.router.command.RemoveRuleRequest",
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.ruleTag !== "") {
            writer.uint32(10).string(message.ruleTag);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveRuleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ruleTag = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { $type: exports.RemoveRuleRequest.$type, ruleTag: isSet(object.ruleTag) ? globalThis.String(object.ruleTag) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.ruleTag !== "") {
            obj.ruleTag = message.ruleTag;
        }
        return obj;
    },
    create(base) {
        return exports.RemoveRuleRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRemoveRuleRequest();
        message.ruleTag = object.ruleTag ?? "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RemoveRuleRequest.$type, exports.RemoveRuleRequest);
function createBaseRemoveRuleResponse() {
    return { $type: "xray.app.router.command.RemoveRuleResponse" };
}
exports.RemoveRuleResponse = {
    $type: "xray.app.router.command.RemoveRuleResponse",
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveRuleResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return { $type: exports.RemoveRuleResponse.$type };
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.RemoveRuleResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRemoveRuleResponse();
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RemoveRuleResponse.$type, exports.RemoveRuleResponse);
function createBaseConfig() {
    return { $type: "xray.app.router.command.Config" };
}
exports.Config = {
    $type: "xray.app.router.command.Config",
    encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return { $type: exports.Config.$type };
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.Config.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseConfig();
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Config.$type, exports.Config);
exports.RoutingServiceDefinition = {
    name: "RoutingService",
    fullName: "xray.app.router.command.RoutingService",
    methods: {
        subscribeRoutingStats: {
            name: "SubscribeRoutingStats",
            requestType: exports.SubscribeRoutingStatsRequest,
            requestStream: false,
            responseType: exports.RoutingContext,
            responseStream: true,
            options: {},
        },
        testRoute: {
            name: "TestRoute",
            requestType: exports.TestRouteRequest,
            requestStream: false,
            responseType: exports.RoutingContext,
            responseStream: false,
            options: {},
        },
        getBalancerInfo: {
            name: "GetBalancerInfo",
            requestType: exports.GetBalancerInfoRequest,
            requestStream: false,
            responseType: exports.GetBalancerInfoResponse,
            responseStream: false,
            options: {},
        },
        overrideBalancerTarget: {
            name: "OverrideBalancerTarget",
            requestType: exports.OverrideBalancerTargetRequest,
            requestStream: false,
            responseType: exports.OverrideBalancerTargetResponse,
            responseStream: false,
            options: {},
        },
        addRule: {
            name: "AddRule",
            requestType: exports.AddRuleRequest,
            requestStream: false,
            responseType: exports.AddRuleResponse,
            responseStream: false,
            options: {},
        },
        removeRule: {
            name: "RemoveRule",
            requestType: exports.RemoveRuleRequest,
            requestStream: false,
            responseType: exports.RemoveRuleResponse,
            responseStream: false,
            options: {},
        },
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
