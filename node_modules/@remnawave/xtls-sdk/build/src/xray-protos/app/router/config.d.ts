import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Network } from "../../common/net/network";
import { PortList } from "../../common/net/port";
import { TypedMessage } from "../../common/serial/typed_message";
export declare const protobufPackage = "xray.app.router";
/** Domain for routing decision. */
export interface Domain {
    $type: "xray.app.router.Domain";
    /** Domain matching type. */
    type: Domain_Type;
    /** Domain value. */
    value: string;
    /** Attributes of this domain. May be used for filtering. */
    attribute: Domain_Attribute[];
}
/** Type of domain value. */
export declare enum Domain_Type {
    /** Plain - The value is used as is. */
    Plain = 0,
    /** Regex - The value is used as a regular expression. */
    Regex = 1,
    /** Domain - The value is a root domain. */
    Domain = 2,
    /** Full - The value is a domain. */
    Full = 3,
    UNRECOGNIZED = -1
}
export declare function domain_TypeFromJSON(object: any): Domain_Type;
export declare function domain_TypeToJSON(object: Domain_Type): string;
export interface Domain_Attribute {
    $type: "xray.app.router.Domain.Attribute";
    key: string;
    boolValue?: boolean | undefined;
    intValue?: number | undefined;
}
/** IP for routing decision, in CIDR form. */
export interface CIDR {
    $type: "xray.app.router.CIDR";
    /** IP address, should be either 4 or 16 bytes. */
    ip: Uint8Array;
    /** Number of leading ones in the network mask. */
    prefix: number;
}
export interface GeoIP {
    $type: "xray.app.router.GeoIP";
    countryCode: string;
    cidr: CIDR[];
    reverseMatch: boolean;
}
export interface GeoIPList {
    $type: "xray.app.router.GeoIPList";
    entry: GeoIP[];
}
export interface GeoSite {
    $type: "xray.app.router.GeoSite";
    countryCode: string;
    domain: Domain[];
}
export interface GeoSiteList {
    $type: "xray.app.router.GeoSiteList";
    entry: GeoSite[];
}
export interface RoutingRule {
    $type: "xray.app.router.RoutingRule";
    /** Tag of outbound that this rule is pointing to. */
    tag?: string | undefined;
    /** Tag of routing balancer. */
    balancingTag?: string | undefined;
    ruleTag: string;
    /** List of domains for target domain matching. */
    domain: Domain[];
    /**
     * List of GeoIPs for target IP address matching. If this entry exists, the
     * cidr above will have no effect. GeoIP fields with the same country code are
     * supposed to contain exactly same content. They will be merged during
     * runtime. For customized GeoIPs, please leave country code empty.
     */
    geoip: GeoIP[];
    /** List of ports. */
    portList: PortList | undefined;
    /** List of networks for matching. */
    networks: Network[];
    /**
     * List of GeoIPs for source IP address matching. If this entry exists, the
     * source_cidr above will have no effect.
     */
    sourceGeoip: GeoIP[];
    /** List of ports for source port matching. */
    sourcePortList: PortList | undefined;
    userEmail: string[];
    inboundTag: string[];
    protocol: string[];
    attributes: {
        [key: string]: string;
    };
    localGeoip: GeoIP[];
    localPortList: PortList | undefined;
    vlessRouteList: PortList | undefined;
}
export interface RoutingRule_AttributesEntry {
    $type: "xray.app.router.RoutingRule.AttributesEntry";
    key: string;
    value: string;
}
export interface BalancingRule {
    $type: "xray.app.router.BalancingRule";
    tag: string;
    outboundSelector: string[];
    strategy: string;
    strategySettings: TypedMessage | undefined;
    fallbackTag: string;
}
export interface StrategyWeight {
    $type: "xray.app.router.StrategyWeight";
    regexp: boolean;
    match: string;
    value: number;
}
export interface StrategyLeastLoadConfig {
    $type: "xray.app.router.StrategyLeastLoadConfig";
    /** weight settings */
    costs: StrategyWeight[];
    /** RTT baselines for selecting, int64 values of time.Duration */
    baselines: number[];
    /** expected nodes count to select */
    expected: number;
    /** max acceptable rtt, filter away high delay nodes. default 0 */
    maxRTT: number;
    /** acceptable failure rate */
    tolerance: number;
}
export interface Config {
    $type: "xray.app.router.Config";
    domainStrategy: Config_DomainStrategy;
    rule: RoutingRule[];
    balancingRule: BalancingRule[];
}
export declare enum Config_DomainStrategy {
    /** AsIs - Use domain as is. */
    AsIs = 0,
    /** IpIfNonMatch - Resolve to IP if the domain doesn't match any rules. */
    IpIfNonMatch = 2,
    /** IpOnDemand - Resolve to IP if any rule requires IP matching. */
    IpOnDemand = 3,
    UNRECOGNIZED = -1
}
export declare function config_DomainStrategyFromJSON(object: any): Config_DomainStrategy;
export declare function config_DomainStrategyToJSON(object: Config_DomainStrategy): string;
export declare const Domain: MessageFns<Domain, "xray.app.router.Domain">;
export declare const Domain_Attribute: MessageFns<Domain_Attribute, "xray.app.router.Domain.Attribute">;
export declare const CIDR: MessageFns<CIDR, "xray.app.router.CIDR">;
export declare const GeoIP: MessageFns<GeoIP, "xray.app.router.GeoIP">;
export declare const GeoIPList: MessageFns<GeoIPList, "xray.app.router.GeoIPList">;
export declare const GeoSite: MessageFns<GeoSite, "xray.app.router.GeoSite">;
export declare const GeoSiteList: MessageFns<GeoSiteList, "xray.app.router.GeoSiteList">;
export declare const RoutingRule: MessageFns<RoutingRule, "xray.app.router.RoutingRule">;
export declare const RoutingRule_AttributesEntry: MessageFns<RoutingRule_AttributesEntry, "xray.app.router.RoutingRule.AttributesEntry">;
export declare const BalancingRule: MessageFns<BalancingRule, "xray.app.router.BalancingRule">;
export declare const StrategyWeight: MessageFns<StrategyWeight, "xray.app.router.StrategyWeight">;
export declare const StrategyLeastLoadConfig: MessageFns<StrategyLeastLoadConfig, "xray.app.router.StrategyLeastLoadConfig">;
export declare const Config: MessageFns<Config, "xray.app.router.Config">;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T, V extends string> {
    readonly $type: V;
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=config.d.ts.map