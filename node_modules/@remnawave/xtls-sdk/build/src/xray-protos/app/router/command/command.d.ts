import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Network } from "../../../common/net/network";
import { TypedMessage } from "../../../common/serial/typed_message";
export declare const protobufPackage = "xray.app.router.command";
/**
 * RoutingContext is the context with information relative to routing process.
 * It conforms to the structure of xray.features.routing.Context and
 * xray.features.routing.Route.
 */
export interface RoutingContext {
    $type: "xray.app.router.command.RoutingContext";
    InboundTag: string;
    Network: Network;
    SourceIPs: Uint8Array[];
    TargetIPs: Uint8Array[];
    SourcePort: number;
    TargetPort: number;
    TargetDomain: string;
    Protocol: string;
    User: string;
    Attributes: {
        [key: string]: string;
    };
    OutboundGroupTags: string[];
    OutboundTag: string;
    LocalIPs: Uint8Array[];
    LocalPort: number;
    VlessRoute: number;
}
export interface RoutingContext_AttributesEntry {
    $type: "xray.app.router.command.RoutingContext.AttributesEntry";
    key: string;
    value: string;
}
/**
 * SubscribeRoutingStatsRequest subscribes to routing statistics channel if
 * opened by xray-core.
 * * FieldSelectors selects a subset of fields in routing statistics to return.
 * Valid selectors:
 *  - inbound: Selects connection's inbound tag.
 *  - network: Selects connection's network.
 *  - ip: Equivalent as "ip_source" and "ip_target", selects both source and
 *  target IP.
 *  - port: Equivalent as "port_source" and "port_target", selects both source
 *  and target port.
 *  - domain: Selects target domain.
 *  - protocol: Select connection's protocol.
 *  - user: Select connection's inbound user email.
 *  - attributes: Select connection's additional attributes.
 *  - outbound: Equivalent as "outbound" and "outbound_group", select both
 *  outbound tag and outbound group tags.
 * * If FieldSelectors is left empty, all fields will be returned.
 */
export interface SubscribeRoutingStatsRequest {
    $type: "xray.app.router.command.SubscribeRoutingStatsRequest";
    FieldSelectors: string[];
}
/**
 * TestRouteRequest manually tests a routing result according to the routing
 * context message.
 * * RoutingContext is the routing message without outbound information.
 * * FieldSelectors selects the fields to return in the routing result. All
 * fields are returned if left empty.
 * * PublishResult broadcasts the routing result to routing statistics channel
 * if set true.
 */
export interface TestRouteRequest {
    $type: "xray.app.router.command.TestRouteRequest";
    RoutingContext: RoutingContext | undefined;
    FieldSelectors: string[];
    PublishResult: boolean;
}
export interface PrincipleTargetInfo {
    $type: "xray.app.router.command.PrincipleTargetInfo";
    tag: string[];
}
export interface OverrideInfo {
    $type: "xray.app.router.command.OverrideInfo";
    target: string;
}
export interface BalancerMsg {
    $type: "xray.app.router.command.BalancerMsg";
    override: OverrideInfo | undefined;
    principleTarget: PrincipleTargetInfo | undefined;
}
export interface GetBalancerInfoRequest {
    $type: "xray.app.router.command.GetBalancerInfoRequest";
    tag: string;
}
export interface GetBalancerInfoResponse {
    $type: "xray.app.router.command.GetBalancerInfoResponse";
    balancer: BalancerMsg | undefined;
}
export interface OverrideBalancerTargetRequest {
    $type: "xray.app.router.command.OverrideBalancerTargetRequest";
    balancerTag: string;
    target: string;
}
export interface OverrideBalancerTargetResponse {
    $type: "xray.app.router.command.OverrideBalancerTargetResponse";
}
export interface AddRuleRequest {
    $type: "xray.app.router.command.AddRuleRequest";
    config: TypedMessage | undefined;
    shouldAppend: boolean;
}
export interface AddRuleResponse {
    $type: "xray.app.router.command.AddRuleResponse";
}
export interface RemoveRuleRequest {
    $type: "xray.app.router.command.RemoveRuleRequest";
    ruleTag: string;
}
export interface RemoveRuleResponse {
    $type: "xray.app.router.command.RemoveRuleResponse";
}
export interface Config {
    $type: "xray.app.router.command.Config";
}
export declare const RoutingContext: MessageFns<RoutingContext, "xray.app.router.command.RoutingContext">;
export declare const RoutingContext_AttributesEntry: MessageFns<RoutingContext_AttributesEntry, "xray.app.router.command.RoutingContext.AttributesEntry">;
export declare const SubscribeRoutingStatsRequest: MessageFns<SubscribeRoutingStatsRequest, "xray.app.router.command.SubscribeRoutingStatsRequest">;
export declare const TestRouteRequest: MessageFns<TestRouteRequest, "xray.app.router.command.TestRouteRequest">;
export declare const PrincipleTargetInfo: MessageFns<PrincipleTargetInfo, "xray.app.router.command.PrincipleTargetInfo">;
export declare const OverrideInfo: MessageFns<OverrideInfo, "xray.app.router.command.OverrideInfo">;
export declare const BalancerMsg: MessageFns<BalancerMsg, "xray.app.router.command.BalancerMsg">;
export declare const GetBalancerInfoRequest: MessageFns<GetBalancerInfoRequest, "xray.app.router.command.GetBalancerInfoRequest">;
export declare const GetBalancerInfoResponse: MessageFns<GetBalancerInfoResponse, "xray.app.router.command.GetBalancerInfoResponse">;
export declare const OverrideBalancerTargetRequest: MessageFns<OverrideBalancerTargetRequest, "xray.app.router.command.OverrideBalancerTargetRequest">;
export declare const OverrideBalancerTargetResponse: MessageFns<OverrideBalancerTargetResponse, "xray.app.router.command.OverrideBalancerTargetResponse">;
export declare const AddRuleRequest: MessageFns<AddRuleRequest, "xray.app.router.command.AddRuleRequest">;
export declare const AddRuleResponse: MessageFns<AddRuleResponse, "xray.app.router.command.AddRuleResponse">;
export declare const RemoveRuleRequest: MessageFns<RemoveRuleRequest, "xray.app.router.command.RemoveRuleRequest">;
export declare const RemoveRuleResponse: MessageFns<RemoveRuleResponse, "xray.app.router.command.RemoveRuleResponse">;
export declare const Config: MessageFns<Config, "xray.app.router.command.Config">;
export type RoutingServiceDefinition = typeof RoutingServiceDefinition;
export declare const RoutingServiceDefinition: {
    readonly name: "RoutingService";
    readonly fullName: "xray.app.router.command.RoutingService";
    readonly methods: {
        readonly subscribeRoutingStats: {
            readonly name: "SubscribeRoutingStats";
            readonly requestType: MessageFns<SubscribeRoutingStatsRequest, "xray.app.router.command.SubscribeRoutingStatsRequest">;
            readonly requestStream: false;
            readonly responseType: MessageFns<RoutingContext, "xray.app.router.command.RoutingContext">;
            readonly responseStream: true;
            readonly options: {};
        };
        readonly testRoute: {
            readonly name: "TestRoute";
            readonly requestType: MessageFns<TestRouteRequest, "xray.app.router.command.TestRouteRequest">;
            readonly requestStream: false;
            readonly responseType: MessageFns<RoutingContext, "xray.app.router.command.RoutingContext">;
            readonly responseStream: false;
            readonly options: {};
        };
        readonly getBalancerInfo: {
            readonly name: "GetBalancerInfo";
            readonly requestType: MessageFns<GetBalancerInfoRequest, "xray.app.router.command.GetBalancerInfoRequest">;
            readonly requestStream: false;
            readonly responseType: MessageFns<GetBalancerInfoResponse, "xray.app.router.command.GetBalancerInfoResponse">;
            readonly responseStream: false;
            readonly options: {};
        };
        readonly overrideBalancerTarget: {
            readonly name: "OverrideBalancerTarget";
            readonly requestType: MessageFns<OverrideBalancerTargetRequest, "xray.app.router.command.OverrideBalancerTargetRequest">;
            readonly requestStream: false;
            readonly responseType: MessageFns<OverrideBalancerTargetResponse, "xray.app.router.command.OverrideBalancerTargetResponse">;
            readonly responseStream: false;
            readonly options: {};
        };
        readonly addRule: {
            readonly name: "AddRule";
            readonly requestType: MessageFns<AddRuleRequest, "xray.app.router.command.AddRuleRequest">;
            readonly requestStream: false;
            readonly responseType: MessageFns<AddRuleResponse, "xray.app.router.command.AddRuleResponse">;
            readonly responseStream: false;
            readonly options: {};
        };
        readonly removeRule: {
            readonly name: "RemoveRule";
            readonly requestType: MessageFns<RemoveRuleRequest, "xray.app.router.command.RemoveRuleRequest">;
            readonly requestStream: false;
            readonly responseType: MessageFns<RemoveRuleResponse, "xray.app.router.command.RemoveRuleResponse">;
            readonly responseStream: false;
            readonly options: {};
        };
    };
};
export interface RoutingServiceImplementation<CallContextExt = {}> {
    subscribeRoutingStats(request: SubscribeRoutingStatsRequest, context: CallContext & CallContextExt): ServerStreamingMethodResult<DeepPartial<RoutingContext>>;
    testRoute(request: TestRouteRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RoutingContext>>;
    getBalancerInfo(request: GetBalancerInfoRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetBalancerInfoResponse>>;
    overrideBalancerTarget(request: OverrideBalancerTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OverrideBalancerTargetResponse>>;
    addRule(request: AddRuleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<AddRuleResponse>>;
    removeRule(request: RemoveRuleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RemoveRuleResponse>>;
}
export interface RoutingServiceClient<CallOptionsExt = {}> {
    subscribeRoutingStats(request: DeepPartial<SubscribeRoutingStatsRequest>, options?: CallOptions & CallOptionsExt): AsyncIterable<RoutingContext>;
    testRoute(request: DeepPartial<TestRouteRequest>, options?: CallOptions & CallOptionsExt): Promise<RoutingContext>;
    getBalancerInfo(request: DeepPartial<GetBalancerInfoRequest>, options?: CallOptions & CallOptionsExt): Promise<GetBalancerInfoResponse>;
    overrideBalancerTarget(request: DeepPartial<OverrideBalancerTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<OverrideBalancerTargetResponse>;
    addRule(request: DeepPartial<AddRuleRequest>, options?: CallOptions & CallOptionsExt): Promise<AddRuleResponse>;
    removeRule(request: DeepPartial<RemoveRuleRequest>, options?: CallOptions & CallOptionsExt): Promise<RemoveRuleResponse>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]>;
} : Partial<T>;
export type ServerStreamingMethodResult<Response> = {
    [Symbol.asyncIterator](): AsyncIterator<Response, void>;
};
export interface MessageFns<T, V extends string> {
    readonly $type: V;
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=command.d.ts.map