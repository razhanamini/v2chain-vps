import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { IPOrDomain } from "../../common/net/address";
import { PortList } from "../../common/net/port";
import { TypedMessage } from "../../common/serial/typed_message";
import { DomainStrategy, ProxyConfig, StreamConfig } from "../../transport/internet/config";
export declare const protobufPackage = "xray.app.proxyman";
export interface InboundConfig {
    $type: "xray.app.proxyman.InboundConfig";
}
export interface SniffingConfig {
    $type: "xray.app.proxyman.SniffingConfig";
    /** Whether or not to enable content sniffing on an inbound connection. */
    enabled: boolean;
    /**
     * Override target destination if sniff'ed protocol is in the given list.
     * Supported values are "http", "tls", "fakedns".
     */
    destinationOverride: string[];
    domainsExcluded: string[];
    /**
     * Whether should only try to sniff metadata without waiting for client input.
     * Can be used to support SMTP like protocol where server send the first
     * message.
     */
    metadataOnly: boolean;
    routeOnly: boolean;
}
export interface ReceiverConfig {
    $type: "xray.app.proxyman.ReceiverConfig";
    /** PortList specifies the ports which the Receiver should listen on. */
    portList: PortList | undefined;
    /** Listen specifies the IP address that the Receiver should listen on. */
    listen: IPOrDomain | undefined;
    streamSettings: StreamConfig | undefined;
    receiveOriginalDestination: boolean;
    sniffingSettings: SniffingConfig | undefined;
}
export interface InboundHandlerConfig {
    $type: "xray.app.proxyman.InboundHandlerConfig";
    tag: string;
    receiverSettings: TypedMessage | undefined;
    proxySettings: TypedMessage | undefined;
}
export interface OutboundConfig {
    $type: "xray.app.proxyman.OutboundConfig";
}
export interface SenderConfig {
    $type: "xray.app.proxyman.SenderConfig";
    /** Send traffic through the given IP. Only IP is allowed. */
    via: IPOrDomain | undefined;
    streamSettings: StreamConfig | undefined;
    proxySettings: ProxyConfig | undefined;
    multiplexSettings: MultiplexingConfig | undefined;
    viaCidr: string;
    targetStrategy: DomainStrategy;
}
export interface MultiplexingConfig {
    $type: "xray.app.proxyman.MultiplexingConfig";
    /** Whether or not Mux is enabled. */
    enabled: boolean;
    /** Max number of concurrent connections that one Mux connection can handle. */
    concurrency: number;
    /** Transport XUDP in another Mux. */
    xudpConcurrency: number;
    /** "reject" (default), "allow" or "skip". */
    xudpProxyUDP443: string;
}
export declare const InboundConfig: MessageFns<InboundConfig, "xray.app.proxyman.InboundConfig">;
export declare const SniffingConfig: MessageFns<SniffingConfig, "xray.app.proxyman.SniffingConfig">;
export declare const ReceiverConfig: MessageFns<ReceiverConfig, "xray.app.proxyman.ReceiverConfig">;
export declare const InboundHandlerConfig: MessageFns<InboundHandlerConfig, "xray.app.proxyman.InboundHandlerConfig">;
export declare const OutboundConfig: MessageFns<OutboundConfig, "xray.app.proxyman.OutboundConfig">;
export declare const SenderConfig: MessageFns<SenderConfig, "xray.app.proxyman.SenderConfig">;
export declare const MultiplexingConfig: MessageFns<MultiplexingConfig, "xray.app.proxyman.MultiplexingConfig">;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T, V extends string> {
    readonly $type: V;
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
//# sourceMappingURL=config.d.ts.map